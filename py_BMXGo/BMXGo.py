
# python wrapper for package BMXGo within overall package BMXGo
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build --output=py_BMXGo -vm=python3 .

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _BMXGo
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from BMXGo import BMXGo
# and then refer to everything using BMXGo. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice []*x509.Certificate
class Slice_Ptr_x509_Certificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_Ptr_x509_Certificate_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_x509_Certificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_Ptr_x509_Certificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_Ptr_x509_Certificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_Ptr_x509_Certificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_Ptr_x509_Certificate_len(self.handle)
				return Slice_Ptr_x509_Certificate(handle=_BMXGo.Slice_Ptr_x509_Certificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_x509_Certificate(handle=_BMXGo.Slice_Ptr_x509_Certificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_Ptr_x509_Certificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_x509_Certificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_x509_Certificate(handle=_BMXGo.Slice_Ptr_x509_Certificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_Ptr_x509_Certificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*multipart.FileHeader
class Slice_Ptr_multipart_FileHeader(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_Ptr_multipart_FileHeader_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_multipart_FileHeader.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_Ptr_multipart_FileHeader len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_Ptr_multipart_FileHeader([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_Ptr_multipart_FileHeader_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_Ptr_multipart_FileHeader_len(self.handle)
				return Slice_Ptr_multipart_FileHeader(handle=_BMXGo.Slice_Ptr_multipart_FileHeader_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_multipart_FileHeader(handle=_BMXGo.Slice_Ptr_multipart_FileHeader_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_Ptr_multipart_FileHeader_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_multipart_FileHeader.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_multipart_FileHeader(handle=_BMXGo.Slice_Ptr_multipart_FileHeader_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_Ptr_multipart_FileHeader_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*net.IPNet
class Slice_Ptr_net_IPNet(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_Ptr_net_IPNet_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_net_IPNet.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_Ptr_net_IPNet len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_Ptr_net_IPNet([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_Ptr_net_IPNet_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_Ptr_net_IPNet_len(self.handle)
				return Slice_Ptr_net_IPNet(handle=_BMXGo.Slice_Ptr_net_IPNet_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_net_IPNet(handle=_BMXGo.Slice_Ptr_net_IPNet_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_Ptr_net_IPNet_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_net_IPNet.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_net_IPNet(handle=_BMXGo.Slice_Ptr_net_IPNet_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_Ptr_net_IPNet_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*http.Cookie
class Slice_Ptr_http_Cookie(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_Ptr_http_Cookie_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_http_Cookie.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_Ptr_http_Cookie len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_Ptr_http_Cookie([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_Ptr_http_Cookie_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_Ptr_http_Cookie_len(self.handle)
				return Slice_Ptr_http_Cookie(handle=_BMXGo.Slice_Ptr_http_Cookie_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_http_Cookie(handle=_BMXGo.Slice_Ptr_http_Cookie_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_Ptr_http_Cookie_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_http_Cookie.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_http_Cookie(handle=_BMXGo.Slice_Ptr_http_Cookie_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_Ptr_http_Cookie_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*url.URL
class Slice_Ptr_url_URL(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_Ptr_url_URL_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_url_URL.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_Ptr_url_URL len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_Ptr_url_URL([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_Ptr_url_URL_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_Ptr_url_URL_len(self.handle)
				return Slice_Ptr_url_URL(handle=_BMXGo.Slice_Ptr_url_URL_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_url_URL(handle=_BMXGo.Slice_Ptr_url_URL_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_Ptr_url_URL_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_url_URL.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_url_URL(handle=_BMXGo.Slice_Ptr_url_URL_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_Ptr_url_URL_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []BMXGo.ConvMessage
class Slice_BMXGo_ConvMessage(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_BMXGo_ConvMessage_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_BMXGo_ConvMessage.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_BMXGo_ConvMessage len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_BMXGo_ConvMessage([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_BMXGo_ConvMessage_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_BMXGo_ConvMessage_len(self.handle)
				return Slice_BMXGo_ConvMessage(handle=_BMXGo.Slice_BMXGo_ConvMessage_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return ConvMessage(handle=_BMXGo.Slice_BMXGo_ConvMessage_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_BMXGo_ConvMessage_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_BMXGo_ConvMessage.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = ConvMessage(handle=_BMXGo.Slice_BMXGo_ConvMessage_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_BMXGo_ConvMessage_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []BMXGo.LinkedContent
class Slice_BMXGo_LinkedContent(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_BMXGo_LinkedContent_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_BMXGo_LinkedContent.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_BMXGo_LinkedContent len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_BMXGo_LinkedContent([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_BMXGo_LinkedContent_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_BMXGo_LinkedContent_len(self.handle)
				return Slice_BMXGo_LinkedContent(handle=_BMXGo.Slice_BMXGo_LinkedContent_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return LinkedContent(handle=_BMXGo.Slice_BMXGo_LinkedContent_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_BMXGo_LinkedContent_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_BMXGo_LinkedContent.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = LinkedContent(handle=_BMXGo.Slice_BMXGo_LinkedContent_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_BMXGo_LinkedContent_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []BMXGo.SearchResults
class Slice_BMXGo_SearchResults(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_BMXGo_SearchResults_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_BMXGo_SearchResults.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_BMXGo_SearchResults len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_BMXGo_SearchResults([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_BMXGo_SearchResults_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_BMXGo_SearchResults_len(self.handle)
				return Slice_BMXGo_SearchResults(handle=_BMXGo.Slice_BMXGo_SearchResults_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return SearchResults(handle=_BMXGo.Slice_BMXGo_SearchResults_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_BMXGo_SearchResults_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_BMXGo_SearchResults.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = SearchResults(handle=_BMXGo.Slice_BMXGo_SearchResults_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_BMXGo_SearchResults_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][]*x509.Certificate
class Slice_Slice_Ptr_x509_Certificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_Slice_Ptr_x509_Certificate_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_Ptr_x509_Certificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_Slice_Ptr_x509_Certificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_Slice_Ptr_x509_Certificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_Slice_Ptr_x509_Certificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_Slice_Ptr_x509_Certificate_len(self.handle)
				return Slice_Slice_Ptr_x509_Certificate(handle=_BMXGo.Slice_Slice_Ptr_x509_Certificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Slice_Ptr_x509_Certificate(handle=_BMXGo.Slice_Slice_Ptr_x509_Certificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_Slice_Ptr_x509_Certificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_Ptr_x509_Certificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Slice_Ptr_x509_Certificate(handle=_BMXGo.Slice_Slice_Ptr_x509_Certificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_Slice_Ptr_x509_Certificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][]byte
class Slice_Slice_byte(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_Slice_byte_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_byte.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_Slice_byte len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_Slice_byte([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_Slice_byte_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_Slice_byte_len(self.handle)
				return Slice_Slice_byte(handle=_BMXGo.Slice_Slice_byte_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_byte(handle=_BMXGo.Slice_Slice_byte_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_Slice_byte_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_byte.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Slice_byte(handle=_BMXGo.Slice_Slice_byte_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_Slice_byte_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][]string
class Slice_Slice_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_Slice_string_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_string.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_Slice_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_Slice_string([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_Slice_string_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_Slice_string_len(self.handle)
				return Slice_Slice_string(handle=_BMXGo.Slice_Slice_string_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_string(handle=_BMXGo.Slice_Slice_string_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_Slice_string_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_string.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Slice_string(handle=_BMXGo.Slice_Slice_string_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_Slice_string_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []x509.ExtKeyUsage
class Slice_x509_ExtKeyUsage(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_x509_ExtKeyUsage_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_x509_ExtKeyUsage.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_x509_ExtKeyUsage len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_x509_ExtKeyUsage([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_x509_ExtKeyUsage_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_x509_ExtKeyUsage_len(self.handle)
				return Slice_x509_ExtKeyUsage(handle=_BMXGo.Slice_x509_ExtKeyUsage_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _BMXGo.Slice_x509_ExtKeyUsage_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_x509_ExtKeyUsage_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_x509_ExtKeyUsage.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _BMXGo.Slice_x509_ExtKeyUsage_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_x509_ExtKeyUsage_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []x509.OID
class Slice_x509_OID(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_x509_OID_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_x509_OID.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_x509_OID len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_x509_OID([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_x509_OID_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_x509_OID_len(self.handle)
				return Slice_x509_OID(handle=_BMXGo.Slice_x509_OID_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.x509_OID(handle=_BMXGo.Slice_x509_OID_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_x509_OID_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_x509_OID.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.x509_OID(handle=_BMXGo.Slice_x509_OID_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_x509_OID_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []pkix.AttributeTypeAndValue
class Slice_pkix_AttributeTypeAndValue(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_pkix_AttributeTypeAndValue_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pkix_AttributeTypeAndValue.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_pkix_AttributeTypeAndValue len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_pkix_AttributeTypeAndValue([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_pkix_AttributeTypeAndValue_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_pkix_AttributeTypeAndValue_len(self.handle)
				return Slice_pkix_AttributeTypeAndValue(handle=_BMXGo.Slice_pkix_AttributeTypeAndValue_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.pkix_AttributeTypeAndValue(handle=_BMXGo.Slice_pkix_AttributeTypeAndValue_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_pkix_AttributeTypeAndValue_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pkix_AttributeTypeAndValue.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.pkix_AttributeTypeAndValue(handle=_BMXGo.Slice_pkix_AttributeTypeAndValue_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_pkix_AttributeTypeAndValue_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []pkix.Extension
class Slice_pkix_Extension(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_pkix_Extension_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pkix_Extension.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_pkix_Extension len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_pkix_Extension([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_pkix_Extension_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_pkix_Extension_len(self.handle)
				return Slice_pkix_Extension(handle=_BMXGo.Slice_pkix_Extension_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.pkix_Extension(handle=_BMXGo.Slice_pkix_Extension_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_pkix_Extension_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pkix_Extension.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.pkix_Extension(handle=_BMXGo.Slice_pkix_Extension_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_pkix_Extension_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []pkix.RevokedCertificate
class Slice_pkix_RevokedCertificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_pkix_RevokedCertificate_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pkix_RevokedCertificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_pkix_RevokedCertificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_pkix_RevokedCertificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_pkix_RevokedCertificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_pkix_RevokedCertificate_len(self.handle)
				return Slice_pkix_RevokedCertificate(handle=_BMXGo.Slice_pkix_RevokedCertificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.pkix_RevokedCertificate(handle=_BMXGo.Slice_pkix_RevokedCertificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_pkix_RevokedCertificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pkix_RevokedCertificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.pkix_RevokedCertificate(handle=_BMXGo.Slice_pkix_RevokedCertificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_pkix_RevokedCertificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []asn1.ObjectIdentifier
class Slice_asn1_ObjectIdentifier(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_asn1_ObjectIdentifier_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_asn1_ObjectIdentifier.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_asn1_ObjectIdentifier len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_asn1_ObjectIdentifier([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_asn1_ObjectIdentifier_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_asn1_ObjectIdentifier_len(self.handle)
				return Slice_asn1_ObjectIdentifier(handle=_BMXGo.Slice_asn1_ObjectIdentifier_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.asn1_ObjectIdentifier(handle=_BMXGo.Slice_asn1_ObjectIdentifier_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_asn1_ObjectIdentifier_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_asn1_ObjectIdentifier.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.asn1_ObjectIdentifier(handle=_BMXGo.Slice_asn1_ObjectIdentifier_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_asn1_ObjectIdentifier_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []big.Word
class Slice_big_Word(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_big_Word_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_big_Word.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_big_Word len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_big_Word([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_big_Word_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_big_Word_len(self.handle)
				return Slice_big_Word(handle=_BMXGo.Slice_big_Word_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _BMXGo.Slice_big_Word_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_big_Word_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_big_Word.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _BMXGo.Slice_big_Word_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_big_Word_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []net.IP
class Slice_net_IP(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Slice_net_IP_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_net_IP.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Slice_net_IP len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'BMXGo.Slice_net_IP([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _BMXGo.Slice_net_IP_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _BMXGo.Slice_net_IP_len(self.handle)
				return Slice_net_IP(handle=_BMXGo.Slice_net_IP_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.net_IP(handle=_BMXGo.Slice_net_IP_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_BMXGo.Slice_net_IP_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_net_IP.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.net_IP(handle=_BMXGo.Slice_net_IP_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_BMXGo.Slice_net_IP_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[string]BMXGo.Document
class Map_string_BMXGo_Document(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Map_string_BMXGo_Document_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_BMXGo_Document.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_BMXGo.Map_string_BMXGo_Document_set(self.handle, k, v)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Map_string_BMXGo_Document len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'BMXGo.Map_string_BMXGo_Document({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _BMXGo.Map_string_BMXGo_Document_len(self.handle)
	def __getitem__(self, key):
		return Document(handle=_BMXGo.Map_string_BMXGo_Document_elem(self.handle, key))
	def __setitem__(self, key, value):
		_BMXGo.Map_string_BMXGo_Document_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _BMXGo.Map_string_BMXGo_Document_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_BMXGo.Map_string_BMXGo_Document_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _BMXGo.Map_string_BMXGo_Document_contains(self.handle, key)

# Python type for map map[string][]*multipart.FileHeader
class Map_string_Slice_Ptr_multipart_FileHeader(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Map_string_Slice_Ptr_multipart_FileHeader_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Slice_Ptr_multipart_FileHeader.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_BMXGo.Map_string_Slice_Ptr_multipart_FileHeader_set(self.handle, k, v)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Map_string_Slice_Ptr_multipart_FileHeader len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'BMXGo.Map_string_Slice_Ptr_multipart_FileHeader({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _BMXGo.Map_string_Slice_Ptr_multipart_FileHeader_len(self.handle)
	def __getitem__(self, key):
		return Slice_Ptr_multipart_FileHeader(handle=_BMXGo.Map_string_Slice_Ptr_multipart_FileHeader_elem(self.handle, key))
	def __setitem__(self, key, value):
		_BMXGo.Map_string_Slice_Ptr_multipart_FileHeader_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _BMXGo.Map_string_Slice_Ptr_multipart_FileHeader_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_BMXGo.Map_string_Slice_Ptr_multipart_FileHeader_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _BMXGo.Map_string_Slice_Ptr_multipart_FileHeader_contains(self.handle, key)

# Python type for map map[string][]string
class Map_string_Slice_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Map_string_Slice_string_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Slice_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_BMXGo.Map_string_Slice_string_set(self.handle, k, v)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Map_string_Slice_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'BMXGo.Map_string_Slice_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _BMXGo.Map_string_Slice_string_len(self.handle)
	def __getitem__(self, key):
		return go.Slice_string(handle=_BMXGo.Map_string_Slice_string_elem(self.handle, key))
	def __setitem__(self, key, value):
		_BMXGo.Map_string_Slice_string_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _BMXGo.Map_string_Slice_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_BMXGo.Map_string_Slice_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _BMXGo.Map_string_Slice_string_contains(self.handle, key)

# Python type for map map[string]bool
class Map_string_bool(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Map_string_bool_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_bool.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_BMXGo.Map_string_bool_set(self.handle, k, v)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Map_string_bool len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'BMXGo.Map_string_bool({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _BMXGo.Map_string_bool_len(self.handle)
	def __getitem__(self, key):
		return _BMXGo.Map_string_bool_elem(self.handle, key)
	def __setitem__(self, key, value):
		_BMXGo.Map_string_bool_set(self.handle, key, value)
	def __delitem__(self, key):
		return _BMXGo.Map_string_bool_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_BMXGo.Map_string_bool_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _BMXGo.Map_string_bool_contains(self.handle, key)

# Python type for map map[string]float64
class Map_string_float64(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Map_string_float64_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_float64.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_BMXGo.Map_string_float64_set(self.handle, k, v)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Map_string_float64 len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'BMXGo.Map_string_float64({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _BMXGo.Map_string_float64_len(self.handle)
	def __getitem__(self, key):
		return _BMXGo.Map_string_float64_elem(self.handle, key)
	def __setitem__(self, key, value):
		_BMXGo.Map_string_float64_set(self.handle, key, value)
	def __delitem__(self, key):
		return _BMXGo.Map_string_float64_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_BMXGo.Map_string_float64_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _BMXGo.Map_string_float64_contains(self.handle, key)

# Python type for map map[string]int
class Map_string_int(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.Map_string_int_CTor()
			_BMXGo.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_int.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_BMXGo.Map_string_int_set(self.handle, k, v)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		s = 'BMXGo.Map_string_int len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'BMXGo.Map_string_int({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _BMXGo.Map_string_int_len(self.handle)
	def __getitem__(self, key):
		return _BMXGo.Map_string_int_elem(self.handle, key)
	def __setitem__(self, key, value):
		_BMXGo.Map_string_int_set(self.handle, key, value)
	def __delitem__(self, key):
		return _BMXGo.Map_string_int_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_BMXGo.Map_string_int_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _BMXGo.Map_string_int_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct BMXGo.Document
class Document(go.GoClass):
	"""Define the parameters and types\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.BMXGo_Document_CTor()
			_BMXGo.IncRef(self.handle)
			if  0 < len(args):
				self.Text = args[0]
			if "Text" in kwargs:
				self.Text = kwargs["Text"]
			if  1 < len(args):
				self.Tokens = args[1]
			if "Tokens" in kwargs:
				self.Tokens = kwargs["Tokens"]
			if  2 < len(args):
				self.F_table = args[2]
			if "F_table" in kwargs:
				self.F_table = kwargs["F_table"]
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.Document{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.Document ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Text(self):
		return _BMXGo.BMXGo_Document_Text_Get(self.handle)
	@Text.setter
	def Text(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Document_Text_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_Document_Text_Set(self.handle, value)
	@property
	def Tokens(self):
		return go.Slice_string(handle=_BMXGo.BMXGo_Document_Tokens_Get(self.handle))
	@Tokens.setter
	def Tokens(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Document_Tokens_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def F_table(self):
		return Map_string_int(handle=_BMXGo.BMXGo_Document_F_table_Get(self.handle))
	@F_table.setter
	def F_table(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Document_F_table_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct BMXGo.Parameters
class Parameters(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.BMXGo_Parameters_CTor()
			_BMXGo.IncRef(self.handle)
			if  0 < len(args):
				self.Alpha = args[0]
			if "Alpha" in kwargs:
				self.Alpha = kwargs["Alpha"]
			if  1 < len(args):
				self.Beta = args[1]
			if "Beta" in kwargs:
				self.Beta = kwargs["Beta"]
			if  2 < len(args):
				self.Avgdl = args[2]
			if "Avgdl" in kwargs:
				self.Avgdl = kwargs["Avgdl"]
			if  3 < len(args):
				self.N = args[3]
			if "N" in kwargs:
				self.N = kwargs["N"]
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.Parameters{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.Parameters ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Alpha(self):
		return _BMXGo.BMXGo_Parameters_Alpha_Get(self.handle)
	@Alpha.setter
	def Alpha(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Parameters_Alpha_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_Parameters_Alpha_Set(self.handle, value)
	@property
	def Beta(self):
		return _BMXGo.BMXGo_Parameters_Beta_Get(self.handle)
	@Beta.setter
	def Beta(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Parameters_Beta_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_Parameters_Beta_Set(self.handle, value)
	@property
	def Avgdl(self):
		return _BMXGo.BMXGo_Parameters_Avgdl_Get(self.handle)
	@Avgdl.setter
	def Avgdl(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Parameters_Avgdl_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_Parameters_Avgdl_Set(self.handle, value)
	@property
	def N(self):
		return _BMXGo.BMXGo_Parameters_N_Get(self.handle)
	@N.setter
	def N(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Parameters_N_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_Parameters_N_Set(self.handle, value)

# Python type for struct BMXGo.Query
class Query(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.BMXGo_Query_CTor()
			_BMXGo.IncRef(self.handle)
			if  0 < len(args):
				self.Text = args[0]
			if "Text" in kwargs:
				self.Text = kwargs["Text"]
			if  1 < len(args):
				self.Tokens = args[1]
			if "Tokens" in kwargs:
				self.Tokens = kwargs["Tokens"]
			if  2 < len(args):
				self.TotalWeight = args[2]
			if "TotalWeight" in kwargs:
				self.TotalWeight = kwargs["TotalWeight"]
			if  5 < len(args):
				self.S_table = args[5]
			if "S_table" in kwargs:
				self.S_table = kwargs["S_table"]
			if  6 < len(args):
				self.ScoreTable = args[6]
			if "ScoreTable" in kwargs:
				self.ScoreTable = kwargs["ScoreTable"]
			if  7 < len(args):
				self.NormalizedScoreTable = args[7]
			if "NormalizedScoreTable" in kwargs:
				self.NormalizedScoreTable = kwargs["NormalizedScoreTable"]
			if  8 < len(args):
				self.AugmentedQueries = args[8]
			if "AugmentedQueries" in kwargs:
				self.AugmentedQueries = kwargs["AugmentedQueries"]
			if  9 < len(args):
				self.AugmentedWeights = args[9]
			if "AugmentedWeights" in kwargs:
				self.AugmentedWeights = kwargs["AugmentedWeights"]
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.Query{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.Query ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Text(self):
		return _BMXGo.BMXGo_Query_Text_Get(self.handle)
	@Text.setter
	def Text(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Query_Text_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_Query_Text_Set(self.handle, value)
	@property
	def Tokens(self):
		return Map_string_float64(handle=_BMXGo.BMXGo_Query_Tokens_Get(self.handle))
	@Tokens.setter
	def Tokens(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Query_Tokens_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def TotalWeight(self):
		return _BMXGo.BMXGo_Query_TotalWeight_Get(self.handle)
	@TotalWeight.setter
	def TotalWeight(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Query_TotalWeight_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_Query_TotalWeight_Set(self.handle, value)
	@property
	def S_table(self):
		return Map_string_float64(handle=_BMXGo.BMXGo_Query_S_table_Get(self.handle))
	@S_table.setter
	def S_table(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Query_S_table_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ScoreTable(self):
		return Map_string_float64(handle=_BMXGo.BMXGo_Query_ScoreTable_Get(self.handle))
	@ScoreTable.setter
	def ScoreTable(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Query_ScoreTable_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def NormalizedScoreTable(self):
		return Map_string_float64(handle=_BMXGo.BMXGo_Query_NormalizedScoreTable_Get(self.handle))
	@NormalizedScoreTable.setter
	def NormalizedScoreTable(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Query_NormalizedScoreTable_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AugmentedQueries(self):
		return go.Slice_string(handle=_BMXGo.BMXGo_Query_AugmentedQueries_Get(self.handle))
	@AugmentedQueries.setter
	def AugmentedQueries(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Query_AugmentedQueries_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AugmentedWeights(self):
		return go.Slice_float64(handle=_BMXGo.BMXGo_Query_AugmentedWeights_Get(self.handle))
	@AugmentedWeights.setter
	def AugmentedWeights(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Query_AugmentedWeights_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def SetEntropy(self, bmx, goRun=False):
		"""SetEntropy(object bmx) """
		_BMXGo.BMXGo_Query_SetEntropy(self.handle, bmx.handle, goRun)
	def S_table_fill(self, bmx, goRun=False):
		"""S_table_fill(object bmx) 
		
		Function to calculate S(Q, D)
		"""
		_BMXGo.BMXGo_Query_S_table_fill(self.handle, bmx.handle, goRun)
	def Score_table_fill(self, bmx, goRun=False):
		"""Score_table_fill(object bmx) 
		
		Function to calculate the score
		"""
		_BMXGo.BMXGo_Query_Score_table_fill(self.handle, bmx.handle, goRun)
	def NormalizedScore_table_fill(self, bmx, goRun=False):
		"""NormalizedScore_table_fill(object bmx) """
		_BMXGo.BMXGo_Query_NormalizedScore_table_fill(self.handle, bmx.handle, goRun)
	def Initialize(self, bmx, goRun=False):
		"""Initialize(object bmx) """
		_BMXGo.BMXGo_Query_Initialize(self.handle, bmx.handle, goRun)
	def Rank(self, topK):
		"""Rank(int topK) []str"""
		return go.Slice_string(handle=_BMXGo.BMXGo_Query_Rank(self.handle, topK))

# Python type for struct BMXGo.BMX
class BMX(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.BMXGo_BMX_CTor()
			_BMXGo.IncRef(self.handle)
			if  0 < len(args):
				self.Docs = args[0]
			if "Docs" in kwargs:
				self.Docs = kwargs["Docs"]
			if  1 < len(args):
				self.Params = args[1]
			if "Params" in kwargs:
				self.Params = kwargs["Params"]
			if  2 < len(args):
				self.TextPreprocessor = args[2]
			if "TextPreprocessor" in kwargs:
				self.TextPreprocessor = kwargs["TextPreprocessor"]
			if  3 < len(args):
				self.NumAppearances = args[3]
			if "NumAppearances" in kwargs:
				self.NumAppearances = kwargs["NumAppearances"]
			if  4 < len(args):
				self.IDF_table = args[4]
			if "IDF_table" in kwargs:
				self.IDF_table = kwargs["IDF_table"]
			if  5 < len(args):
				self.E_tilde_table = args[5]
			if "E_tilde_table" in kwargs:
				self.E_tilde_table = kwargs["E_tilde_table"]
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.BMX{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.BMX ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Docs(self):
		return Map_string_BMXGo_Document(handle=_BMXGo.BMXGo_BMX_Docs_Get(self.handle))
	@Docs.setter
	def Docs(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_BMX_Docs_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Params(self):
		return Parameters(handle=_BMXGo.BMXGo_BMX_Params_Get(self.handle))
	@Params.setter
	def Params(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_BMX_Params_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def TextPreprocessor(self):
		return TextPreprocessor(handle=_BMXGo.BMXGo_BMX_TextPreprocessor_Get(self.handle))
	@TextPreprocessor.setter
	def TextPreprocessor(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_BMX_TextPreprocessor_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def NumAppearances(self):
		return Map_string_Slice_string(handle=_BMXGo.BMXGo_BMX_NumAppearances_Get(self.handle))
	@NumAppearances.setter
	def NumAppearances(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_BMX_NumAppearances_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def IDF_table(self):
		return Map_string_float64(handle=_BMXGo.BMXGo_BMX_IDF_table_Get(self.handle))
	@IDF_table.setter
	def IDF_table(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_BMX_IDF_table_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def E_tilde_table(self):
		return Map_string_float64(handle=_BMXGo.BMXGo_BMX_E_tilde_table_Get(self.handle))
	@E_tilde_table.setter
	def E_tilde_table(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_BMX_E_tilde_table_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def InitializeTextPreprocessor(self, config):
		"""InitializeTextPreprocessor(object config) str"""
		return _BMXGo.BMXGo_BMX_InitializeTextPreprocessor(self.handle, config.handle)
	def SetParams(self, goRun=False):
		"""SetParams() """
		_BMXGo.BMXGo_BMX_SetParams(self.handle, goRun)
	def F_table_fill(self, goRun=False):
		"""F_table_fill() """
		_BMXGo.BMXGo_BMX_F_table_fill(self.handle, goRun)
	def NumAppearancesCalc(self, goRun=False):
		"""NumAppearancesCalc() """
		_BMXGo.BMXGo_BMX_NumAppearancesCalc(self.handle, goRun)
	def IDF_table_fill(self, goRun=False):
		"""IDF_table_fill() """
		_BMXGo.BMXGo_BMX_IDF_table_fill(self.handle, goRun)
	def E_tilde_table_fill(self, goRun=False):
		"""E_tilde_table_fill() """
		_BMXGo.BMXGo_BMX_E_tilde_table_fill(self.handle, goRun)

# Python type for struct BMXGo.BMXAdapter
class BMXAdapter(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.BMXGo_BMXAdapter_CTor()
			_BMXGo.IncRef(self.handle)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.BMXAdapter{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.BMXAdapter ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def AddMany(self, ids, docs):
		"""AddMany([]str ids, []str docs) str"""
		return _BMXGo.BMXGo_BMXAdapter_AddMany(self.handle, ids.handle, docs.handle)
	def Search(self, query, topK):
		"""Search(str query, int topK) object"""
		return SearchResults(handle=_BMXGo.BMXGo_BMXAdapter_Search(self.handle, query, topK))
	def SearchMany(self, queries, topK, maxConcurrent):
		"""SearchMany([]str queries, int topK, int maxConcurrent) []object"""
		return Slice_BMXGo_SearchResults(handle=_BMXGo.BMXGo_BMXAdapter_SearchMany(self.handle, queries.handle, topK, maxConcurrent))
	def SearchAugmented(self, query, topK, num_augmented_queries, weight):
		"""SearchAugmented(str query, int topK, int num_augmented_queries, float weight) object"""
		return SearchResults(handle=_BMXGo.BMXGo_BMXAdapter_SearchAugmented(self.handle, query, topK, num_augmented_queries, weight))
	def SearchAugmentedMany(self, queries, topK, num_augmented_queries, weight, maxConcurrent):
		"""SearchAugmentedMany([]str queries, int topK, int num_augmented_queries, float weight, int maxConcurrent) []object"""
		return Slice_BMXGo_SearchResults(handle=_BMXGo.BMXGo_BMXAdapter_SearchAugmentedMany(self.handle, queries.handle, topK, num_augmented_queries, weight, maxConcurrent))
	def SearchAugmentedMany2(self, queries, topK, num_augmented_queries, weight, maxConcurrent):
		"""SearchAugmentedMany2([]str queries, int topK, int num_augmented_queries, float weight, int maxConcurrent) []object"""
		return Slice_BMXGo_SearchResults(handle=_BMXGo.BMXGo_BMXAdapter_SearchAugmentedMany2(self.handle, queries.handle, topK, num_augmented_queries, weight, maxConcurrent))
	def GetTokens(self, text, goRun=False):
		"""GetTokens(str text) """
		_BMXGo.BMXGo_BMXAdapter_GetTokens(self.handle, text, goRun)

# Python type for struct BMXGo.ChatCompletionRequest
class ChatCompletionRequest(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.BMXGo_ChatCompletionRequest_CTor()
			_BMXGo.IncRef(self.handle)
			if  0 < len(args):
				self.Models = args[0]
			if "Models" in kwargs:
				self.Models = kwargs["Models"]
			if  1 < len(args):
				self.Messages = args[1]
			if "Messages" in kwargs:
				self.Messages = kwargs["Messages"]
			if  2 < len(args):
				self.Stream = args[2]
			if "Stream" in kwargs:
				self.Stream = kwargs["Stream"]
			if  3 < len(args):
				self.Temperature = args[3]
			if "Temperature" in kwargs:
				self.Temperature = kwargs["Temperature"]
			if  4 < len(args):
				self.MaxTokens = args[4]
			if "MaxTokens" in kwargs:
				self.MaxTokens = kwargs["MaxTokens"]
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.ChatCompletionRequest{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.ChatCompletionRequest ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Models(self):
		return go.Slice_string(handle=_BMXGo.BMXGo_ChatCompletionRequest_Models_Get(self.handle))
	@Models.setter
	def Models(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ChatCompletionRequest_Models_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Messages(self):
		return Slice_BMXGo_ConvMessage(handle=_BMXGo.BMXGo_ChatCompletionRequest_Messages_Get(self.handle))
	@Messages.setter
	def Messages(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ChatCompletionRequest_Messages_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Stream(self):
		return _BMXGo.BMXGo_ChatCompletionRequest_Stream_Get(self.handle)
	@Stream.setter
	def Stream(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ChatCompletionRequest_Stream_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_ChatCompletionRequest_Stream_Set(self.handle, value)
	@property
	def Temperature(self):
		return _BMXGo.BMXGo_ChatCompletionRequest_Temperature_Get(self.handle)
	@Temperature.setter
	def Temperature(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ChatCompletionRequest_Temperature_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_ChatCompletionRequest_Temperature_Set(self.handle, value)
	@property
	def MaxTokens(self):
		return _BMXGo.BMXGo_ChatCompletionRequest_MaxTokens_Get(self.handle)
	@MaxTokens.setter
	def MaxTokens(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ChatCompletionRequest_MaxTokens_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_ChatCompletionRequest_MaxTokens_Set(self.handle, value)

# Python type for struct BMXGo.ClientConfig
class ClientConfig(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.BMXGo_ClientConfig_CTor()
			_BMXGo.IncRef(self.handle)
			if  0 < len(args):
				self.APIKey = args[0]
			if "APIKey" in kwargs:
				self.APIKey = kwargs["APIKey"]
			if  1 < len(args):
				self.BaseURL = args[1]
			if "BaseURL" in kwargs:
				self.BaseURL = kwargs["BaseURL"]
			if  2 < len(args):
				self.HTTPClient = args[2]
			if "HTTPClient" in kwargs:
				self.HTTPClient = kwargs["HTTPClient"]
			if  3 < len(args):
				self.AppName = args[3]
			if "AppName" in kwargs:
				self.AppName = kwargs["AppName"]
			if  4 < len(args):
				self.AppURL = args[4]
			if "AppURL" in kwargs:
				self.AppURL = kwargs["AppURL"]
			if  5 < len(args):
				self.Provider = args[5]
			if "Provider" in kwargs:
				self.Provider = kwargs["Provider"]
			if  6 < len(args):
				self.ResourceName = args[6]
			if "ResourceName" in kwargs:
				self.ResourceName = kwargs["ResourceName"]
			if  7 < len(args):
				self.DeploymentName = args[7]
			if "DeploymentName" in kwargs:
				self.DeploymentName = kwargs["DeploymentName"]
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.ClientConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.ClientConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def APIKey(self):
		return _BMXGo.BMXGo_ClientConfig_APIKey_Get(self.handle)
	@APIKey.setter
	def APIKey(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ClientConfig_APIKey_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_ClientConfig_APIKey_Set(self.handle, value)
	@property
	def BaseURL(self):
		return _BMXGo.BMXGo_ClientConfig_BaseURL_Get(self.handle)
	@BaseURL.setter
	def BaseURL(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ClientConfig_BaseURL_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_ClientConfig_BaseURL_Set(self.handle, value)
	@property
	def HTTPClient(self):
		return go.Ptr_http_Client(handle=_BMXGo.BMXGo_ClientConfig_HTTPClient_Get(self.handle))
	@HTTPClient.setter
	def HTTPClient(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ClientConfig_HTTPClient_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AppName(self):
		return _BMXGo.BMXGo_ClientConfig_AppName_Get(self.handle)
	@AppName.setter
	def AppName(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ClientConfig_AppName_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_ClientConfig_AppName_Set(self.handle, value)
	@property
	def AppURL(self):
		return _BMXGo.BMXGo_ClientConfig_AppURL_Get(self.handle)
	@AppURL.setter
	def AppURL(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ClientConfig_AppURL_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_ClientConfig_AppURL_Set(self.handle, value)
	@property
	def Provider(self):
		return _BMXGo.BMXGo_ClientConfig_Provider_Get(self.handle)
	@Provider.setter
	def Provider(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ClientConfig_Provider_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_ClientConfig_Provider_Set(self.handle, value)
	@property
	def ResourceName(self):
		return _BMXGo.BMXGo_ClientConfig_ResourceName_Get(self.handle)
	@ResourceName.setter
	def ResourceName(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ClientConfig_ResourceName_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_ClientConfig_ResourceName_Set(self.handle, value)
	@property
	def DeploymentName(self):
		return _BMXGo.BMXGo_ClientConfig_DeploymentName_Get(self.handle)
	@DeploymentName.setter
	def DeploymentName(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ClientConfig_DeploymentName_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_ClientConfig_DeploymentName_Set(self.handle, value)

# Python type for struct BMXGo.SearchResults
class SearchResults(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.BMXGo_SearchResults_CTor()
			_BMXGo.IncRef(self.handle)
			if  0 < len(args):
				self.Keys = args[0]
			if "Keys" in kwargs:
				self.Keys = kwargs["Keys"]
			if  1 < len(args):
				self.Scores = args[1]
			if "Scores" in kwargs:
				self.Scores = kwargs["Scores"]
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.SearchResults{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.SearchResults ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Keys(self):
		return go.Slice_string(handle=_BMXGo.BMXGo_SearchResults_Keys_Get(self.handle))
	@Keys.setter
	def Keys(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_SearchResults_Keys_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Scores(self):
		return go.Slice_float64(handle=_BMXGo.BMXGo_SearchResults_Scores_Get(self.handle))
	@Scores.setter
	def Scores(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_SearchResults_Scores_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct BMXGo.TextPreprocessor
class TextPreprocessor(go.GoClass):
	"""TextPreprocessor holds the preprocessing steps and configuration.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.BMXGo_TextPreprocessor_CTor()
			_BMXGo.IncRef(self.handle)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.TextPreprocessor{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.TextPreprocessor ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Process(self, item):
		"""Process(str item) []str
		
		Process processes a single text item through all preprocessing steps.
		"""
		return go.Slice_string(handle=_BMXGo.BMXGo_TextPreprocessor_Process(self.handle, item))
	def ProcessMany(self, items, nWorkers):
		"""ProcessMany([]str items, int nWorkers) [][]str
		
		ProcessMany processes multiple text items concurrently.
		"""
		return Slice_Slice_string(handle=_BMXGo.BMXGo_TextPreprocessor_ProcessMany(self.handle, items.handle, nWorkers))
	def SetStemmer(self, stemmerName):
		"""SetStemmer(str stemmerName) str
		
		Add a method to set the stemmer
		"""
		return _BMXGo.BMXGo_TextPreprocessor_SetStemmer(self.handle, stemmerName)
	def SetStopwords(self, stopwords):
		"""SetStopwords(str stopwords) str
		
		Add a method to set stopwords
		"""
		return _BMXGo.BMXGo_TextPreprocessor_SetStopwords(self.handle, stopwords)

# Python type for struct BMXGo.Config
class Config(go.GoClass):
	"""Config holds the configuration for text preprocessing.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.BMXGo_Config_CTor()
			_BMXGo.IncRef(self.handle)
			if  3 < len(args):
				self.DoLowercasing = args[3]
			if "DoLowercasing" in kwargs:
				self.DoLowercasing = kwargs["DoLowercasing"]
			if  4 < len(args):
				self.DoAmpersandNormalization = args[4]
			if "DoAmpersandNormalization" in kwargs:
				self.DoAmpersandNormalization = kwargs["DoAmpersandNormalization"]
			if  5 < len(args):
				self.DoSpecialCharsNormalization = args[5]
			if "DoSpecialCharsNormalization" in kwargs:
				self.DoSpecialCharsNormalization = kwargs["DoSpecialCharsNormalization"]
			if  6 < len(args):
				self.DoAcronymsNormalization = args[6]
			if "DoAcronymsNormalization" in kwargs:
				self.DoAcronymsNormalization = kwargs["DoAcronymsNormalization"]
			if  7 < len(args):
				self.DoPunctuationRemoval = args[7]
			if "DoPunctuationRemoval" in kwargs:
				self.DoPunctuationRemoval = kwargs["DoPunctuationRemoval"]
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.Config{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.Config ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def DoLowercasing(self):
		return _BMXGo.BMXGo_Config_DoLowercasing_Get(self.handle)
	@DoLowercasing.setter
	def DoLowercasing(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Config_DoLowercasing_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_Config_DoLowercasing_Set(self.handle, value)
	@property
	def DoAmpersandNormalization(self):
		return _BMXGo.BMXGo_Config_DoAmpersandNormalization_Get(self.handle)
	@DoAmpersandNormalization.setter
	def DoAmpersandNormalization(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Config_DoAmpersandNormalization_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_Config_DoAmpersandNormalization_Set(self.handle, value)
	@property
	def DoSpecialCharsNormalization(self):
		return _BMXGo.BMXGo_Config_DoSpecialCharsNormalization_Get(self.handle)
	@DoSpecialCharsNormalization.setter
	def DoSpecialCharsNormalization(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Config_DoSpecialCharsNormalization_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_Config_DoSpecialCharsNormalization_Set(self.handle, value)
	@property
	def DoAcronymsNormalization(self):
		return _BMXGo.BMXGo_Config_DoAcronymsNormalization_Get(self.handle)
	@DoAcronymsNormalization.setter
	def DoAcronymsNormalization(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Config_DoAcronymsNormalization_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_Config_DoAcronymsNormalization_Set(self.handle, value)
	@property
	def DoPunctuationRemoval(self):
		return _BMXGo.BMXGo_Config_DoPunctuationRemoval_Get(self.handle)
	@DoPunctuationRemoval.setter
	def DoPunctuationRemoval(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_Config_DoPunctuationRemoval_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_Config_DoPunctuationRemoval_Set(self.handle, value)

# Python type for struct BMXGo.ConvMessage
class ConvMessage(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.BMXGo_ConvMessage_CTor()
			_BMXGo.IncRef(self.handle)
			if  0 < len(args):
				self.Role = args[0]
			if "Role" in kwargs:
				self.Role = kwargs["Role"]
			if  1 < len(args):
				self.Content = args[1]
			if "Content" in kwargs:
				self.Content = kwargs["Content"]
			if  2 < len(args):
				self.Date = args[2]
			if "Date" in kwargs:
				self.Date = kwargs["Date"]
			if  3 < len(args):
				self.Intent = args[3]
			if "Intent" in kwargs:
				self.Intent = kwargs["Intent"]
			if  4 < len(args):
				self.LinkedContent = args[4]
			if "LinkedContent" in kwargs:
				self.LinkedContent = kwargs["LinkedContent"]
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.ConvMessage{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.ConvMessage ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Role(self):
		return _BMXGo.BMXGo_ConvMessage_Role_Get(self.handle)
	@Role.setter
	def Role(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ConvMessage_Role_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_ConvMessage_Role_Set(self.handle, value)
	@property
	def Content(self):
		return _BMXGo.BMXGo_ConvMessage_Content_Get(self.handle)
	@Content.setter
	def Content(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ConvMessage_Content_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_ConvMessage_Content_Set(self.handle, value)
	@property
	def Date(self):
		return go.time_Time(handle=_BMXGo.BMXGo_ConvMessage_Date_Get(self.handle))
	@Date.setter
	def Date(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ConvMessage_Date_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Intent(self):
		return _BMXGo.BMXGo_ConvMessage_Intent_Get(self.handle)
	@Intent.setter
	def Intent(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ConvMessage_Intent_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_ConvMessage_Intent_Set(self.handle, value)
	@property
	def LinkedContent(self):
		return Slice_BMXGo_LinkedContent(handle=_BMXGo.BMXGo_ConvMessage_LinkedContent_Get(self.handle))
	@LinkedContent.setter
	def LinkedContent(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_ConvMessage_LinkedContent_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct BMXGo.LLMClient
class LLMClient(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.BMXGo_LLMClient_CTor()
			_BMXGo.IncRef(self.handle)
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.LLMClient{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.LLMClient ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct BMXGo.LinkedContent
class LinkedContent(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_BMXGo.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_BMXGo.IncRef(self.handle)
		else:
			self.handle = _BMXGo.BMXGo_LinkedContent_CTor()
			_BMXGo.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.Type = args[1]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
	def __del__(self):
		_BMXGo.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.LinkedContent{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'BMXGo.LinkedContent ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ID(self):
		return _BMXGo.BMXGo_LinkedContent_ID_Get(self.handle)
	@ID.setter
	def ID(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_LinkedContent_ID_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_LinkedContent_ID_Set(self.handle, value)
	@property
	def Type(self):
		return _BMXGo.BMXGo_LinkedContent_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_BMXGo.BMXGo_LinkedContent_Type_Set(self.handle, value.handle)
		else:
			_BMXGo.BMXGo_LinkedContent_Type_Set(self.handle, value)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def Build(indexName, config):
	"""Build(str indexName, object config) object"""
	return BMXAdapter(handle=_BMXGo.BMXGo_Build(indexName, config.handle))
def NewTextPreprocessor(config):
	"""NewTextPreprocessor(object config) object
	
	NewTextPreprocessor creates a new TextPreprocessor with the given configuration.
	"""
	return TextPreprocessor(handle=_BMXGo.BMXGo_NewTextPreprocessor(config.handle))
def NewConfig(tokenizer, stemmer, lang):
	"""NewConfig(str tokenizer, str stemmer, str lang) object, str
	
	NewConfig creates a new Config with the specified tokenizer, stemmer, and stopwords.
	"""
	return Config(handle=_BMXGo.BMXGo_NewConfig(tokenizer, stemmer, lang))
def NewLLMClient(config):
	"""NewLLMClient(object config) object"""
	return LLMClient(handle=_BMXGo.BMXGo_NewLLMClient(config.handle))


# ---- Functions ---
def NormalizeAcronyms(text):
	"""NormalizeAcronyms(str text) str"""
	return _BMXGo.BMXGo_NormalizeAcronyms(text)
def RemoveEmptyTokens(tokens):
	"""RemoveEmptyTokens([]str tokens) []str"""
	return go.Slice_string(handle=_BMXGo.BMXGo_RemoveEmptyTokens(tokens.handle))
def RemovePunctuation(text):
	"""RemovePunctuation(str text) str"""
	return _BMXGo.BMXGo_RemovePunctuation(text)
def ApplyStemmer(tokens, stemmer):
	"""ApplyStemmer([]str tokens, callable stemmer) []str"""
	return go.Slice_string(handle=_BMXGo.BMXGo_ApplyStemmer(tokens.handle, stemmer))
def GenerateAugmentedQueries(query, num_augmented_queries):
	"""GenerateAugmentedQueries(str query, int num_augmented_queries) []str, str"""
	return go.Slice_string(handle=_BMXGo.BMXGo_GenerateAugmentedQueries(query, num_augmented_queries))
def HtmlToMarkdown(htmlContent, addIDs):
	"""HtmlToMarkdown(str htmlContent, bool addIDs) str"""
	return _BMXGo.BMXGo_HtmlToMarkdown(htmlContent, addIDs)
def NormalizeDiacritics(text):
	"""NormalizeDiacritics(str text) str"""
	return _BMXGo.BMXGo_NormalizeDiacritics(text)
def StripWhitespaces(text):
	"""StripWhitespaces(str text) str"""
	return _BMXGo.BMXGo_StripWhitespaces(text)
def GetStopwords(swList):
	"""GetStopwords(str swList) []str, str"""
	return go.Slice_string(handle=_BMXGo.BMXGo_GetStopwords(swList))
def Lowercasing(text):
	"""Lowercasing(str text) str"""
	return _BMXGo.BMXGo_Lowercasing(text)
def NormalizeAmpersand(text):
	"""NormalizeAmpersand(str text) str"""
	return _BMXGo.BMXGo_NormalizeAmpersand(text)
def NormalizeSpecialChars(text):
	"""NormalizeSpecialChars(str text) str"""
	return _BMXGo.BMXGo_NormalizeSpecialChars(text)


