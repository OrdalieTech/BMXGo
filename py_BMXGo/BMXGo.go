/*
cgo stubs for package BMXGo.
File is generated by gopy. Do not edit.
gopy build --output=py_BMXGo -vm=python3 .
*/

package main

/*

#cgo CFLAGS: "-I/opt/homebrew/opt/python@3.12/Frameworks/Python.framework/Versions/3.12/include/python3.12" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: "-L/opt/homebrew/opt/python@3.12/Frameworks/Python.framework/Versions/3.12/lib" "-lpython3.12" -ldl  -framework CoreFoundation

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"BMXGo"
	"context"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/asn1"
	"fmt"
	"io"
	"math/big"
	"math/rand"
	"mime/multipart"
	"net"
	"net/http"
	"net/textproto"
	"net/url"
	"time"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: BMXGo below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *tls.ConnectionState
func ptrFromHandle_Ptr_tls_ConnectionState(h CGoHandle) *tls.ConnectionState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tls.ConnectionState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.ConnectionState{})).(*tls.ConnectionState)
}
func handleFromPtr_Ptr_tls_ConnectionState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tls.ConnectionState", p))
}

// Converters for pointer handles for type: *x509.CertPool
func ptrFromHandle_Ptr_x509_CertPool(h CGoHandle) *x509.CertPool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*x509.CertPool")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.CertPool{})).(*x509.CertPool)
}
func handleFromPtr_Ptr_x509_CertPool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*x509.CertPool", p))
}

// Converters for pointer handles for type: *x509.Certificate
func ptrFromHandle_Ptr_x509_Certificate(h CGoHandle) *x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*x509.Certificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.Certificate{})).(*x509.Certificate)
}
func handleFromPtr_Ptr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*x509.Certificate", p))
}

// Converters for pointer handles for type: *pkix.CertificateList
func ptrFromHandle_Ptr_pkix_CertificateList(h CGoHandle) *pkix.CertificateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pkix.CertificateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.CertificateList{})).(*pkix.CertificateList)
}
func handleFromPtr_Ptr_pkix_CertificateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pkix.CertificateList", p))
}

// Converters for pointer handles for type: *pkix.RDNSequence
func ptrFromHandle_Ptr_pkix_RDNSequence(h CGoHandle) *pkix.RDNSequence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pkix.RDNSequence")
	if p == nil {
		return nil
	}
	return p.(*pkix.RDNSequence)
}
func handleFromPtr_Ptr_pkix_RDNSequence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pkix.RDNSequence", p))
}

// Converters for pointer handles for type: *big.Int
func ptrFromHandle_Ptr_big_Int(h CGoHandle) *big.Int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*big.Int")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(big.Int{})).(*big.Int)
}
func handleFromPtr_Ptr_big_Int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*big.Int", p))
}

// Converters for pointer handles for type: *rand.Rand
func ptrFromHandle_Ptr_rand_Rand(h CGoHandle) *rand.Rand {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rand.Rand")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rand.Rand{})).(*rand.Rand)
}
func handleFromPtr_Ptr_rand_Rand(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rand.Rand", p))
}

// Converters for pointer handles for type: *multipart.FileHeader
func ptrFromHandle_Ptr_multipart_FileHeader(h CGoHandle) *multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.FileHeader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.FileHeader{})).(*multipart.FileHeader)
}
func handleFromPtr_Ptr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.FileHeader", p))
}

// Converters for pointer handles for type: *multipart.Form
func ptrFromHandle_Ptr_multipart_Form(h CGoHandle) *multipart.Form {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.Form")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Form{})).(*multipart.Form)
}
func handleFromPtr_Ptr_multipart_Form(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.Form", p))
}

// Converters for pointer handles for type: *multipart.Part
func ptrFromHandle_Ptr_multipart_Part(h CGoHandle) *multipart.Part {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.Part")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Part{})).(*multipart.Part)
}
func handleFromPtr_Ptr_multipart_Part(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.Part", p))
}

// Converters for pointer handles for type: *multipart.Reader
func ptrFromHandle_Ptr_multipart_Reader(h CGoHandle) *multipart.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.Reader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Reader{})).(*multipart.Reader)
}
func handleFromPtr_Ptr_multipart_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.Reader", p))
}

// Converters for pointer handles for type: *net.IPNet
func ptrFromHandle_Ptr_net_IPNet(h CGoHandle) *net.IPNet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*net.IPNet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(net.IPNet{})).(*net.IPNet)
}
func handleFromPtr_Ptr_net_IPNet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*net.IPNet", p))
}

// Converters for pointer handles for type: *http.Client
func ptrFromHandle_Ptr_http_Client(h CGoHandle) *http.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Client")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Client{})).(*http.Client)
}
func handleFromPtr_Ptr_http_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Client", p))
}

// Converters for pointer handles for type: *http.Cookie
func ptrFromHandle_Ptr_http_Cookie(h CGoHandle) *http.Cookie {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Cookie")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Cookie{})).(*http.Cookie)
}
func handleFromPtr_Ptr_http_Cookie(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Cookie", p))
}

// Converters for pointer handles for type: *http.Request
func ptrFromHandle_Ptr_http_Request(h CGoHandle) *http.Request {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Request")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Request{})).(*http.Request)
}
func handleFromPtr_Ptr_http_Request(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Request", p))
}

// Converters for pointer handles for type: *http.Response
func ptrFromHandle_Ptr_http_Response(h CGoHandle) *http.Response {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Response")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Response{})).(*http.Response)
}
func handleFromPtr_Ptr_http_Response(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Response", p))
}

// Converters for pointer handles for type: *url.URL
func ptrFromHandle_Ptr_url_URL(h CGoHandle) *url.URL {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*url.URL")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.URL{})).(*url.URL)
}
func handleFromPtr_Ptr_url_URL(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*url.URL", p))
}

// Converters for pointer handles for type: *url.Userinfo
func ptrFromHandle_Ptr_url_Userinfo(h CGoHandle) *url.Userinfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*url.Userinfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.Userinfo{})).(*url.Userinfo)
}
func handleFromPtr_Ptr_url_Userinfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*url.Userinfo", p))
}

// Converters for pointer handles for type: *time.Location
func ptrFromHandle_Ptr_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_Ptr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*time.Location", p))
}

// Converters for pointer handles for type: context.Context
func ptrFromHandle_context_Context(h CGoHandle) context.Context {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "context.Context")
	if p == nil {
		return nil
	}
	return p.(context.Context)
}
func handleFromPtr_context_Context(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("context.Context", p))
}

// Converters for non-pointer handles for type: tls.ConnectionState
func ptrFromHandle_tls_ConnectionState(h CGoHandle) *tls.ConnectionState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tls.ConnectionState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.ConnectionState{})).(*tls.ConnectionState)
}
func handleFromPtr_tls_ConnectionState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tls.ConnectionState", p))
}

// Converters for non-pointer handles for type: x509.CertPool
func ptrFromHandle_x509_CertPool(h CGoHandle) *x509.CertPool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.CertPool")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.CertPool{})).(*x509.CertPool)
}
func handleFromPtr_x509_CertPool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.CertPool", p))
}

// Converters for non-pointer handles for type: x509.Certificate
func ptrFromHandle_x509_Certificate(h CGoHandle) *x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.Certificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.Certificate{})).(*x509.Certificate)
}
func handleFromPtr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.Certificate", p))
}

// Converters for non-pointer handles for type: x509.OID
func ptrFromHandle_x509_OID(h CGoHandle) *x509.OID {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.OID")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.OID{})).(*x509.OID)
}
func handleFromPtr_x509_OID(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.OID", p))
}

// Converters for non-pointer handles for type: x509.VerifyOptions
func ptrFromHandle_x509_VerifyOptions(h CGoHandle) *x509.VerifyOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.VerifyOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.VerifyOptions{})).(*x509.VerifyOptions)
}
func handleFromPtr_x509_VerifyOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.VerifyOptions", p))
}

// Converters for non-pointer handles for type: pkix.AlgorithmIdentifier
func ptrFromHandle_pkix_AlgorithmIdentifier(h CGoHandle) *pkix.AlgorithmIdentifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.AlgorithmIdentifier")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.AlgorithmIdentifier{})).(*pkix.AlgorithmIdentifier)
}
func handleFromPtr_pkix_AlgorithmIdentifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.AlgorithmIdentifier", p))
}

// Converters for non-pointer handles for type: pkix.AttributeTypeAndValue
func ptrFromHandle_pkix_AttributeTypeAndValue(h CGoHandle) *pkix.AttributeTypeAndValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.AttributeTypeAndValue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.AttributeTypeAndValue{})).(*pkix.AttributeTypeAndValue)
}
func handleFromPtr_pkix_AttributeTypeAndValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.AttributeTypeAndValue", p))
}

// Converters for non-pointer handles for type: pkix.CertificateList
func ptrFromHandle_pkix_CertificateList(h CGoHandle) *pkix.CertificateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.CertificateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.CertificateList{})).(*pkix.CertificateList)
}
func handleFromPtr_pkix_CertificateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.CertificateList", p))
}

// Converters for non-pointer handles for type: pkix.Extension
func ptrFromHandle_pkix_Extension(h CGoHandle) *pkix.Extension {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.Extension")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.Extension{})).(*pkix.Extension)
}
func handleFromPtr_pkix_Extension(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.Extension", p))
}

// Converters for non-pointer handles for type: pkix.Name
func ptrFromHandle_pkix_Name(h CGoHandle) *pkix.Name {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.Name")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.Name{})).(*pkix.Name)
}
func handleFromPtr_pkix_Name(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.Name", p))
}

// Converters for implicit pointer handles for type: pkix.RDNSequence
func ptrFromHandle_pkix_RDNSequence(h CGoHandle) *pkix.RDNSequence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.RDNSequence")
	if p == nil {
		return nil
	}
	return p.(*pkix.RDNSequence)
}
func deptrFromHandle_pkix_RDNSequence(h CGoHandle) pkix.RDNSequence {
	p := ptrFromHandle_pkix_RDNSequence(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_pkix_RDNSequence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.RDNSequence", p))
}

// Converters for implicit pointer handles for type: pkix.RelativeDistinguishedNameSET
func ptrFromHandle_pkix_RelativeDistinguishedNameSET(h CGoHandle) *pkix.RelativeDistinguishedNameSET {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.RelativeDistinguishedNameSET")
	if p == nil {
		return nil
	}
	return p.(*pkix.RelativeDistinguishedNameSET)
}
func deptrFromHandle_pkix_RelativeDistinguishedNameSET(h CGoHandle) pkix.RelativeDistinguishedNameSET {
	p := ptrFromHandle_pkix_RelativeDistinguishedNameSET(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_pkix_RelativeDistinguishedNameSET(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.RelativeDistinguishedNameSET", p))
}

// --- wrapping slice: pkix.RelativeDistinguishedNameSET ---
//
//export pkix_RelativeDistinguishedNameSET_CTor
func pkix_RelativeDistinguishedNameSET_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_pkix_RelativeDistinguishedNameSET(&pkix.RelativeDistinguishedNameSET{}))
}

//export pkix_RelativeDistinguishedNameSET_len
func pkix_RelativeDistinguishedNameSET_len(handle CGoHandle) int {
	return len(deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle))
}

//export pkix_RelativeDistinguishedNameSET_elem
func pkix_RelativeDistinguishedNameSET_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	return handleFromPtr_pkix_AttributeTypeAndValue(&(s[_idx]))
}

//export pkix_RelativeDistinguishedNameSET_subslice
func pkix_RelativeDistinguishedNameSET_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_pkix_RelativeDistinguishedNameSET(&ss))
}

//export pkix_RelativeDistinguishedNameSET_set
func pkix_RelativeDistinguishedNameSET_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	s[_idx] = *ptrFromHandle_pkix_AttributeTypeAndValue(_vl)
}

//export pkix_RelativeDistinguishedNameSET_append
func pkix_RelativeDistinguishedNameSET_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	*s = append(*s, *ptrFromHandle_pkix_AttributeTypeAndValue(_vl))
}

// Converters for non-pointer handles for type: pkix.RevokedCertificate
func ptrFromHandle_pkix_RevokedCertificate(h CGoHandle) *pkix.RevokedCertificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.RevokedCertificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.RevokedCertificate{})).(*pkix.RevokedCertificate)
}
func handleFromPtr_pkix_RevokedCertificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.RevokedCertificate", p))
}

// Converters for non-pointer handles for type: pkix.TBSCertificateList
func ptrFromHandle_pkix_TBSCertificateList(h CGoHandle) *pkix.TBSCertificateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.TBSCertificateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.TBSCertificateList{})).(*pkix.TBSCertificateList)
}
func handleFromPtr_pkix_TBSCertificateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.TBSCertificateList", p))
}

// Converters for non-pointer handles for type: asn1.BitString
func ptrFromHandle_asn1_BitString(h CGoHandle) *asn1.BitString {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.BitString")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(asn1.BitString{})).(*asn1.BitString)
}
func handleFromPtr_asn1_BitString(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.BitString", p))
}

// Converters for implicit pointer handles for type: asn1.ObjectIdentifier
func ptrFromHandle_asn1_ObjectIdentifier(h CGoHandle) *asn1.ObjectIdentifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.ObjectIdentifier")
	if p == nil {
		return nil
	}
	return p.(*asn1.ObjectIdentifier)
}
func deptrFromHandle_asn1_ObjectIdentifier(h CGoHandle) asn1.ObjectIdentifier {
	p := ptrFromHandle_asn1_ObjectIdentifier(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_asn1_ObjectIdentifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.ObjectIdentifier", p))
}

// --- wrapping slice: asn1.ObjectIdentifier ---
//
//export asn1_ObjectIdentifier_CTor
func asn1_ObjectIdentifier_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_asn1_ObjectIdentifier(&asn1.ObjectIdentifier{}))
}

//export asn1_ObjectIdentifier_len
func asn1_ObjectIdentifier_len(handle CGoHandle) int {
	return len(deptrFromHandle_asn1_ObjectIdentifier(handle))
}

//export asn1_ObjectIdentifier_elem
func asn1_ObjectIdentifier_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_asn1_ObjectIdentifier(handle)
	return C.longlong(s[_idx])
}

//export asn1_ObjectIdentifier_subslice
func asn1_ObjectIdentifier_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_asn1_ObjectIdentifier(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_asn1_ObjectIdentifier(&ss))
}

//export asn1_ObjectIdentifier_set
func asn1_ObjectIdentifier_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_asn1_ObjectIdentifier(handle)
	s[_idx] = int(_vl)
}

//export asn1_ObjectIdentifier_append
func asn1_ObjectIdentifier_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_asn1_ObjectIdentifier(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: asn1.RawContent
func ptrFromHandle_asn1_RawContent(h CGoHandle) *asn1.RawContent {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.RawContent")
	if p == nil {
		return nil
	}
	return p.(*asn1.RawContent)
}
func deptrFromHandle_asn1_RawContent(h CGoHandle) asn1.RawContent {
	p := ptrFromHandle_asn1_RawContent(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_asn1_RawContent(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.RawContent", p))
}

// --- wrapping slice: asn1.RawContent ---
//
//export asn1_RawContent_CTor
func asn1_RawContent_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_asn1_RawContent(&asn1.RawContent{}))
}

//export asn1_RawContent_len
func asn1_RawContent_len(handle CGoHandle) int {
	return len(deptrFromHandle_asn1_RawContent(handle))
}

//export asn1_RawContent_elem
func asn1_RawContent_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_asn1_RawContent(handle)
	return C.char(s[_idx])
}

//export asn1_RawContent_subslice
func asn1_RawContent_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_asn1_RawContent(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_asn1_RawContent(&ss))
}

//export asn1_RawContent_set
func asn1_RawContent_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_asn1_RawContent(handle)
	s[_idx] = byte(_vl)
}

//export asn1_RawContent_append
func asn1_RawContent_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_asn1_RawContent(handle)
	*s = append(*s, byte(_vl))
}

// Converters for non-pointer handles for type: asn1.RawValue
func ptrFromHandle_asn1_RawValue(h CGoHandle) *asn1.RawValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.RawValue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(asn1.RawValue{})).(*asn1.RawValue)
}
func handleFromPtr_asn1_RawValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.RawValue", p))
}

// Converters for pointer handles for type: fmt.ScanState
func ptrFromHandle_fmt_ScanState(h CGoHandle) fmt.ScanState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fmt.ScanState")
	if p == nil {
		return nil
	}
	return p.(fmt.ScanState)
}
func handleFromPtr_fmt_ScanState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fmt.ScanState", p))
}

// Converters for pointer handles for type: fmt.State
func ptrFromHandle_fmt_State(h CGoHandle) fmt.State {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fmt.State")
	if p == nil {
		return nil
	}
	return p.(fmt.State)
}
func handleFromPtr_fmt_State(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fmt.State", p))
}

// Converters for pointer handles for type: io.ReadCloser
func ptrFromHandle_io_ReadCloser(h CGoHandle) io.ReadCloser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.ReadCloser")
	if p == nil {
		return nil
	}
	return p.(io.ReadCloser)
}
func handleFromPtr_io_ReadCloser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.ReadCloser", p))
}

// Converters for pointer handles for type: io.Reader
func ptrFromHandle_io_Reader(h CGoHandle) io.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Reader")
	if p == nil {
		return nil
	}
	return p.(io.Reader)
}
func handleFromPtr_io_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Reader", p))
}

// Converters for pointer handles for type: io.Writer
func ptrFromHandle_io_Writer(h CGoHandle) io.Writer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Writer")
	if p == nil {
		return nil
	}
	return p.(io.Writer)
}
func handleFromPtr_io_Writer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Writer", p))
}

// Converters for non-pointer handles for type: big.Int
func ptrFromHandle_big_Int(h CGoHandle) *big.Int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "big.Int")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(big.Int{})).(*big.Int)
}
func handleFromPtr_big_Int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("big.Int", p))
}

// Converters for non-pointer handles for type: rand.Rand
func ptrFromHandle_rand_Rand(h CGoHandle) *rand.Rand {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rand.Rand")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rand.Rand{})).(*rand.Rand)
}
func handleFromPtr_rand_Rand(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rand.Rand", p))
}

// Converters for pointer handles for type: multipart.File
func ptrFromHandle_multipart_File(h CGoHandle) multipart.File {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.File")
	if p == nil {
		return nil
	}
	return p.(multipart.File)
}
func handleFromPtr_multipart_File(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.File", p))
}

// Converters for non-pointer handles for type: multipart.FileHeader
func ptrFromHandle_multipart_FileHeader(h CGoHandle) *multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.FileHeader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.FileHeader{})).(*multipart.FileHeader)
}
func handleFromPtr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.FileHeader", p))
}

// Converters for non-pointer handles for type: multipart.Form
func ptrFromHandle_multipart_Form(h CGoHandle) *multipart.Form {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.Form")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Form{})).(*multipart.Form)
}
func handleFromPtr_multipart_Form(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.Form", p))
}

// Converters for non-pointer handles for type: multipart.Part
func ptrFromHandle_multipart_Part(h CGoHandle) *multipart.Part {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.Part")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Part{})).(*multipart.Part)
}
func handleFromPtr_multipart_Part(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.Part", p))
}

// Converters for non-pointer handles for type: multipart.Reader
func ptrFromHandle_multipart_Reader(h CGoHandle) *multipart.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.Reader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Reader{})).(*multipart.Reader)
}
func handleFromPtr_multipart_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.Reader", p))
}

// Converters for implicit pointer handles for type: net.IP
func ptrFromHandle_net_IP(h CGoHandle) *net.IP {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IP")
	if p == nil {
		return nil
	}
	return p.(*net.IP)
}
func deptrFromHandle_net_IP(h CGoHandle) net.IP {
	p := ptrFromHandle_net_IP(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_net_IP(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IP", p))
}

// --- wrapping slice: net.IP ---
//
//export net_IP_CTor
func net_IP_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_net_IP(&net.IP{}))
}

//export net_IP_len
func net_IP_len(handle CGoHandle) int {
	return len(deptrFromHandle_net_IP(handle))
}

//export net_IP_elem
func net_IP_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_net_IP(handle)
	return C.char(s[_idx])
}

//export net_IP_subslice
func net_IP_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_net_IP(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_net_IP(&ss))
}

//export net_IP_set
func net_IP_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_net_IP(handle)
	s[_idx] = byte(_vl)
}

//export net_IP_append
func net_IP_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_net_IP(handle)
	*s = append(*s, byte(_vl))
}

// Converters for implicit pointer handles for type: net.IPMask
func ptrFromHandle_net_IPMask(h CGoHandle) *net.IPMask {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IPMask")
	if p == nil {
		return nil
	}
	return p.(*net.IPMask)
}
func deptrFromHandle_net_IPMask(h CGoHandle) net.IPMask {
	p := ptrFromHandle_net_IPMask(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_net_IPMask(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IPMask", p))
}

// --- wrapping slice: net.IPMask ---
//
//export net_IPMask_CTor
func net_IPMask_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_net_IPMask(&net.IPMask{}))
}

//export net_IPMask_len
func net_IPMask_len(handle CGoHandle) int {
	return len(deptrFromHandle_net_IPMask(handle))
}

//export net_IPMask_elem
func net_IPMask_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_net_IPMask(handle)
	return C.char(s[_idx])
}

//export net_IPMask_subslice
func net_IPMask_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_net_IPMask(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_net_IPMask(&ss))
}

//export net_IPMask_set
func net_IPMask_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_net_IPMask(handle)
	s[_idx] = byte(_vl)
}

//export net_IPMask_append
func net_IPMask_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_net_IPMask(handle)
	*s = append(*s, byte(_vl))
}

// Converters for non-pointer handles for type: net.IPNet
func ptrFromHandle_net_IPNet(h CGoHandle) *net.IPNet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IPNet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(net.IPNet{})).(*net.IPNet)
}
func handleFromPtr_net_IPNet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IPNet", p))
}

// Converters for non-pointer handles for type: http.Client
func ptrFromHandle_http_Client(h CGoHandle) *http.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Client")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Client{})).(*http.Client)
}
func handleFromPtr_http_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Client", p))
}

// Converters for non-pointer handles for type: http.Cookie
func ptrFromHandle_http_Cookie(h CGoHandle) *http.Cookie {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Cookie")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Cookie{})).(*http.Cookie)
}
func handleFromPtr_http_Cookie(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Cookie", p))
}

// Converters for pointer handles for type: http.CookieJar
func ptrFromHandle_http_CookieJar(h CGoHandle) http.CookieJar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.CookieJar")
	if p == nil {
		return nil
	}
	return p.(http.CookieJar)
}
func handleFromPtr_http_CookieJar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.CookieJar", p))
}

// Converters for implicit pointer handles for type: http.Header
func ptrFromHandle_http_Header(h CGoHandle) *http.Header {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Header")
	if p == nil {
		return nil
	}
	return p.(*http.Header)
}
func deptrFromHandle_http_Header(h CGoHandle) http.Header {
	p := ptrFromHandle_http_Header(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_http_Header(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Header", p))
}

// --- wrapping map: http.Header ---
//
//export http_Header_CTor
func http_Header_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_http_Header(&http.Header{}))
}

//export http_Header_len
func http_Header_len(handle CGoHandle) int {
	return len(deptrFromHandle_http_Header(handle))
}

//export http_Header_elem
func http_Header_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_http_Header(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export http_Header_contains
func http_Header_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_http_Header(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export http_Header_set
func http_Header_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_http_Header(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export http_Header_delete
func http_Header_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_http_Header(handle)
	delete(s, C.GoString(_ky))
}

//export http_Header_keys
func http_Header_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_http_Header(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for non-pointer handles for type: http.Request
func ptrFromHandle_http_Request(h CGoHandle) *http.Request {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Request")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Request{})).(*http.Request)
}
func handleFromPtr_http_Request(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Request", p))
}

// Converters for non-pointer handles for type: http.Response
func ptrFromHandle_http_Response(h CGoHandle) *http.Response {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Response")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Response{})).(*http.Response)
}
func handleFromPtr_http_Response(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Response", p))
}

// Converters for pointer handles for type: http.RoundTripper
func ptrFromHandle_http_RoundTripper(h CGoHandle) http.RoundTripper {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.RoundTripper")
	if p == nil {
		return nil
	}
	return p.(http.RoundTripper)
}
func handleFromPtr_http_RoundTripper(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.RoundTripper", p))
}

// Converters for implicit pointer handles for type: textproto.MIMEHeader
func ptrFromHandle_textproto_MIMEHeader(h CGoHandle) *textproto.MIMEHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "textproto.MIMEHeader")
	if p == nil {
		return nil
	}
	return p.(*textproto.MIMEHeader)
}
func deptrFromHandle_textproto_MIMEHeader(h CGoHandle) textproto.MIMEHeader {
	p := ptrFromHandle_textproto_MIMEHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_textproto_MIMEHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("textproto.MIMEHeader", p))
}

// --- wrapping map: textproto.MIMEHeader ---
//
//export textproto_MIMEHeader_CTor
func textproto_MIMEHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_textproto_MIMEHeader(&textproto.MIMEHeader{}))
}

//export textproto_MIMEHeader_len
func textproto_MIMEHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_textproto_MIMEHeader(handle))
}

//export textproto_MIMEHeader_elem
func textproto_MIMEHeader_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export textproto_MIMEHeader_contains
func textproto_MIMEHeader_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export textproto_MIMEHeader_set
func textproto_MIMEHeader_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export textproto_MIMEHeader_delete
func textproto_MIMEHeader_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	delete(s, C.GoString(_ky))
}

//export textproto_MIMEHeader_keys
func textproto_MIMEHeader_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for non-pointer handles for type: url.URL
func ptrFromHandle_url_URL(h CGoHandle) *url.URL {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "url.URL")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.URL{})).(*url.URL)
}
func handleFromPtr_url_URL(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("url.URL", p))
}

// Converters for non-pointer handles for type: url.Userinfo
func ptrFromHandle_url_Userinfo(h CGoHandle) *url.Userinfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "url.Userinfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.Userinfo{})).(*url.Userinfo)
}
func handleFromPtr_url_Userinfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("url.Userinfo", p))
}

// Converters for implicit pointer handles for type: url.Values
func ptrFromHandle_url_Values(h CGoHandle) *url.Values {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "url.Values")
	if p == nil {
		return nil
	}
	return p.(*url.Values)
}
func deptrFromHandle_url_Values(h CGoHandle) url.Values {
	p := ptrFromHandle_url_Values(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_url_Values(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("url.Values", p))
}

// --- wrapping map: url.Values ---
//
//export url_Values_CTor
func url_Values_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_url_Values(&url.Values{}))
}

//export url_Values_len
func url_Values_len(handle CGoHandle) int {
	return len(deptrFromHandle_url_Values(handle))
}

//export url_Values_elem
func url_Values_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_url_Values(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export url_Values_contains
func url_Values_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_url_Values(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export url_Values_set
func url_Values_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_url_Values(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export url_Values_delete
func url_Values_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_url_Values(handle)
	delete(s, C.GoString(_ky))
}

//export url_Values_keys
func url_Values_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_url_Values(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for non-pointer handles for type: time.Location
func ptrFromHandle_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Location", p))
}

// Converters for non-pointer handles for type: time.Time
func ptrFromHandle_time_Time(h CGoHandle) *time.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Time{})).(*time.Time)
}
func handleFromPtr_time_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Time", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: BMXGo ---

// ---- Types ---

// Converters for pointer handles for type: *BMXGo.BMX
func ptrFromHandle_Ptr_BMXGo_BMX(h CGoHandle) *BMXGo.BMX {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*BMXGo.BMX")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.BMX{})).(*BMXGo.BMX)
}
func handleFromPtr_Ptr_BMXGo_BMX(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*BMXGo.BMX", p))
}

// Converters for pointer handles for type: *BMXGo.BMXAdapter
func ptrFromHandle_Ptr_BMXGo_BMXAdapter(h CGoHandle) *BMXGo.BMXAdapter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*BMXGo.BMXAdapter")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.BMXAdapter{})).(*BMXGo.BMXAdapter)
}
func handleFromPtr_Ptr_BMXGo_BMXAdapter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*BMXGo.BMXAdapter", p))
}

// Converters for pointer handles for type: *BMXGo.ChatCompletionRequest
func ptrFromHandle_Ptr_BMXGo_ChatCompletionRequest(h CGoHandle) *BMXGo.ChatCompletionRequest {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*BMXGo.ChatCompletionRequest")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.ChatCompletionRequest{})).(*BMXGo.ChatCompletionRequest)
}
func handleFromPtr_Ptr_BMXGo_ChatCompletionRequest(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*BMXGo.ChatCompletionRequest", p))
}

// Converters for pointer handles for type: *BMXGo.ClientConfig
func ptrFromHandle_Ptr_BMXGo_ClientConfig(h CGoHandle) *BMXGo.ClientConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*BMXGo.ClientConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.ClientConfig{})).(*BMXGo.ClientConfig)
}
func handleFromPtr_Ptr_BMXGo_ClientConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*BMXGo.ClientConfig", p))
}

// Converters for pointer handles for type: *BMXGo.Config
func ptrFromHandle_Ptr_BMXGo_Config(h CGoHandle) *BMXGo.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*BMXGo.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.Config{})).(*BMXGo.Config)
}
func handleFromPtr_Ptr_BMXGo_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*BMXGo.Config", p))
}

// Converters for pointer handles for type: *BMXGo.ConvMessage
func ptrFromHandle_Ptr_BMXGo_ConvMessage(h CGoHandle) *BMXGo.ConvMessage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*BMXGo.ConvMessage")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.ConvMessage{})).(*BMXGo.ConvMessage)
}
func handleFromPtr_Ptr_BMXGo_ConvMessage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*BMXGo.ConvMessage", p))
}

// Converters for pointer handles for type: *BMXGo.Document
func ptrFromHandle_Ptr_BMXGo_Document(h CGoHandle) *BMXGo.Document {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*BMXGo.Document")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.Document{})).(*BMXGo.Document)
}
func handleFromPtr_Ptr_BMXGo_Document(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*BMXGo.Document", p))
}

// Converters for pointer handles for type: *BMXGo.LLMClient
func ptrFromHandle_Ptr_BMXGo_LLMClient(h CGoHandle) *BMXGo.LLMClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*BMXGo.LLMClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.LLMClient{})).(*BMXGo.LLMClient)
}
func handleFromPtr_Ptr_BMXGo_LLMClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*BMXGo.LLMClient", p))
}

// Converters for pointer handles for type: *BMXGo.LinkedContent
func ptrFromHandle_Ptr_BMXGo_LinkedContent(h CGoHandle) *BMXGo.LinkedContent {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*BMXGo.LinkedContent")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.LinkedContent{})).(*BMXGo.LinkedContent)
}
func handleFromPtr_Ptr_BMXGo_LinkedContent(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*BMXGo.LinkedContent", p))
}

// Converters for pointer handles for type: *BMXGo.Parameters
func ptrFromHandle_Ptr_BMXGo_Parameters(h CGoHandle) *BMXGo.Parameters {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*BMXGo.Parameters")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.Parameters{})).(*BMXGo.Parameters)
}
func handleFromPtr_Ptr_BMXGo_Parameters(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*BMXGo.Parameters", p))
}

// Converters for pointer handles for type: *BMXGo.Query
func ptrFromHandle_Ptr_BMXGo_Query(h CGoHandle) *BMXGo.Query {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*BMXGo.Query")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.Query{})).(*BMXGo.Query)
}
func handleFromPtr_Ptr_BMXGo_Query(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*BMXGo.Query", p))
}

// Converters for pointer handles for type: *BMXGo.SearchResults
func ptrFromHandle_Ptr_BMXGo_SearchResults(h CGoHandle) *BMXGo.SearchResults {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*BMXGo.SearchResults")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.SearchResults{})).(*BMXGo.SearchResults)
}
func handleFromPtr_Ptr_BMXGo_SearchResults(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*BMXGo.SearchResults", p))
}

// Converters for pointer handles for type: *BMXGo.TextPreprocessor
func ptrFromHandle_Ptr_BMXGo_TextPreprocessor(h CGoHandle) *BMXGo.TextPreprocessor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*BMXGo.TextPreprocessor")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.TextPreprocessor{})).(*BMXGo.TextPreprocessor)
}
func handleFromPtr_Ptr_BMXGo_TextPreprocessor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*BMXGo.TextPreprocessor", p))
}

// Converters for non-pointer handles for type: BMXGo.BMX
func ptrFromHandle_BMXGo_BMX(h CGoHandle) *BMXGo.BMX {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "BMXGo.BMX")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.BMX{})).(*BMXGo.BMX)
}
func handleFromPtr_BMXGo_BMX(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("BMXGo.BMX", p))
}

// Converters for non-pointer handles for type: BMXGo.BMXAdapter
func ptrFromHandle_BMXGo_BMXAdapter(h CGoHandle) *BMXGo.BMXAdapter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "BMXGo.BMXAdapter")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.BMXAdapter{})).(*BMXGo.BMXAdapter)
}
func handleFromPtr_BMXGo_BMXAdapter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("BMXGo.BMXAdapter", p))
}

// Converters for non-pointer handles for type: BMXGo.ChatCompletionRequest
func ptrFromHandle_BMXGo_ChatCompletionRequest(h CGoHandle) *BMXGo.ChatCompletionRequest {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "BMXGo.ChatCompletionRequest")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.ChatCompletionRequest{})).(*BMXGo.ChatCompletionRequest)
}
func handleFromPtr_BMXGo_ChatCompletionRequest(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("BMXGo.ChatCompletionRequest", p))
}

// Converters for non-pointer handles for type: BMXGo.ClientConfig
func ptrFromHandle_BMXGo_ClientConfig(h CGoHandle) *BMXGo.ClientConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "BMXGo.ClientConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.ClientConfig{})).(*BMXGo.ClientConfig)
}
func handleFromPtr_BMXGo_ClientConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("BMXGo.ClientConfig", p))
}

// Converters for non-pointer handles for type: BMXGo.Config
func ptrFromHandle_BMXGo_Config(h CGoHandle) *BMXGo.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "BMXGo.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.Config{})).(*BMXGo.Config)
}
func handleFromPtr_BMXGo_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("BMXGo.Config", p))
}

// Converters for non-pointer handles for type: BMXGo.ConvMessage
func ptrFromHandle_BMXGo_ConvMessage(h CGoHandle) *BMXGo.ConvMessage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "BMXGo.ConvMessage")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.ConvMessage{})).(*BMXGo.ConvMessage)
}
func handleFromPtr_BMXGo_ConvMessage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("BMXGo.ConvMessage", p))
}

// Converters for non-pointer handles for type: BMXGo.Document
func ptrFromHandle_BMXGo_Document(h CGoHandle) *BMXGo.Document {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "BMXGo.Document")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.Document{})).(*BMXGo.Document)
}
func handleFromPtr_BMXGo_Document(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("BMXGo.Document", p))
}

// Converters for non-pointer handles for type: BMXGo.LLMClient
func ptrFromHandle_BMXGo_LLMClient(h CGoHandle) *BMXGo.LLMClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "BMXGo.LLMClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.LLMClient{})).(*BMXGo.LLMClient)
}
func handleFromPtr_BMXGo_LLMClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("BMXGo.LLMClient", p))
}

// Converters for non-pointer handles for type: BMXGo.LinkedContent
func ptrFromHandle_BMXGo_LinkedContent(h CGoHandle) *BMXGo.LinkedContent {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "BMXGo.LinkedContent")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.LinkedContent{})).(*BMXGo.LinkedContent)
}
func handleFromPtr_BMXGo_LinkedContent(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("BMXGo.LinkedContent", p))
}

// Converters for non-pointer handles for type: BMXGo.Parameters
func ptrFromHandle_BMXGo_Parameters(h CGoHandle) *BMXGo.Parameters {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "BMXGo.Parameters")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.Parameters{})).(*BMXGo.Parameters)
}
func handleFromPtr_BMXGo_Parameters(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("BMXGo.Parameters", p))
}

// Converters for non-pointer handles for type: BMXGo.Query
func ptrFromHandle_BMXGo_Query(h CGoHandle) *BMXGo.Query {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "BMXGo.Query")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.Query{})).(*BMXGo.Query)
}
func handleFromPtr_BMXGo_Query(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("BMXGo.Query", p))
}

// Converters for non-pointer handles for type: BMXGo.SearchResults
func ptrFromHandle_BMXGo_SearchResults(h CGoHandle) *BMXGo.SearchResults {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "BMXGo.SearchResults")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.SearchResults{})).(*BMXGo.SearchResults)
}
func handleFromPtr_BMXGo_SearchResults(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("BMXGo.SearchResults", p))
}

// Converters for non-pointer handles for type: BMXGo.TextPreprocessor
func ptrFromHandle_BMXGo_TextPreprocessor(h CGoHandle) *BMXGo.TextPreprocessor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "BMXGo.TextPreprocessor")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(BMXGo.TextPreprocessor{})).(*BMXGo.TextPreprocessor)
}
func handleFromPtr_BMXGo_TextPreprocessor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("BMXGo.TextPreprocessor", p))
}

// Converters for implicit pointer handles for type: []*x509.Certificate
func ptrFromHandle_Slice_Ptr_x509_Certificate(h CGoHandle) *[]*x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*x509.Certificate")
	if p == nil {
		return nil
	}
	return p.(*[]*x509.Certificate)
}
func deptrFromHandle_Slice_Ptr_x509_Certificate(h CGoHandle) []*x509.Certificate {
	p := ptrFromHandle_Slice_Ptr_x509_Certificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*x509.Certificate", p))
}

// --- wrapping slice: []*x509.Certificate ---
//
//export Slice_Ptr_x509_Certificate_CTor
func Slice_Ptr_x509_Certificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_x509_Certificate(&[]*x509.Certificate{}))
}

//export Slice_Ptr_x509_Certificate_len
func Slice_Ptr_x509_Certificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_x509_Certificate(handle))
}

//export Slice_Ptr_x509_Certificate_elem
func Slice_Ptr_x509_Certificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	return handleFromPtr_Ptr_x509_Certificate(&(s[_idx]))
}

//export Slice_Ptr_x509_Certificate_subslice
func Slice_Ptr_x509_Certificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_x509_Certificate(&ss))
}

//export Slice_Ptr_x509_Certificate_set
func Slice_Ptr_x509_Certificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	s[_idx] = ptrFromHandle_Ptr_x509_Certificate(_vl)
}

//export Slice_Ptr_x509_Certificate_append
func Slice_Ptr_x509_Certificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	*s = append(*s, ptrFromHandle_Ptr_x509_Certificate(_vl))
}

// Converters for implicit pointer handles for type: []*multipart.FileHeader
func ptrFromHandle_Slice_Ptr_multipart_FileHeader(h CGoHandle) *[]*multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*multipart.FileHeader")
	if p == nil {
		return nil
	}
	return p.(*[]*multipart.FileHeader)
}
func deptrFromHandle_Slice_Ptr_multipart_FileHeader(h CGoHandle) []*multipart.FileHeader {
	p := ptrFromHandle_Slice_Ptr_multipart_FileHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*multipart.FileHeader", p))
}

// --- wrapping slice: []*multipart.FileHeader ---
//
//export Slice_Ptr_multipart_FileHeader_CTor
func Slice_Ptr_multipart_FileHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_multipart_FileHeader(&[]*multipart.FileHeader{}))
}

//export Slice_Ptr_multipart_FileHeader_len
func Slice_Ptr_multipart_FileHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle))
}

//export Slice_Ptr_multipart_FileHeader_elem
func Slice_Ptr_multipart_FileHeader_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	return handleFromPtr_Ptr_multipart_FileHeader(&(s[_idx]))
}

//export Slice_Ptr_multipart_FileHeader_subslice
func Slice_Ptr_multipart_FileHeader_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_multipart_FileHeader(&ss))
}

//export Slice_Ptr_multipart_FileHeader_set
func Slice_Ptr_multipart_FileHeader_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	s[_idx] = ptrFromHandle_Ptr_multipart_FileHeader(_vl)
}

//export Slice_Ptr_multipart_FileHeader_append
func Slice_Ptr_multipart_FileHeader_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	*s = append(*s, ptrFromHandle_Ptr_multipart_FileHeader(_vl))
}

// Converters for implicit pointer handles for type: []*net.IPNet
func ptrFromHandle_Slice_Ptr_net_IPNet(h CGoHandle) *[]*net.IPNet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*net.IPNet")
	if p == nil {
		return nil
	}
	return p.(*[]*net.IPNet)
}
func deptrFromHandle_Slice_Ptr_net_IPNet(h CGoHandle) []*net.IPNet {
	p := ptrFromHandle_Slice_Ptr_net_IPNet(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_net_IPNet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*net.IPNet", p))
}

// --- wrapping slice: []*net.IPNet ---
//
//export Slice_Ptr_net_IPNet_CTor
func Slice_Ptr_net_IPNet_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_net_IPNet(&[]*net.IPNet{}))
}

//export Slice_Ptr_net_IPNet_len
func Slice_Ptr_net_IPNet_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_net_IPNet(handle))
}

//export Slice_Ptr_net_IPNet_elem
func Slice_Ptr_net_IPNet_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_net_IPNet(handle)
	return handleFromPtr_Ptr_net_IPNet(&(s[_idx]))
}

//export Slice_Ptr_net_IPNet_subslice
func Slice_Ptr_net_IPNet_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_net_IPNet(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_net_IPNet(&ss))
}

//export Slice_Ptr_net_IPNet_set
func Slice_Ptr_net_IPNet_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_net_IPNet(handle)
	s[_idx] = ptrFromHandle_Ptr_net_IPNet(_vl)
}

//export Slice_Ptr_net_IPNet_append
func Slice_Ptr_net_IPNet_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_net_IPNet(handle)
	*s = append(*s, ptrFromHandle_Ptr_net_IPNet(_vl))
}

// Converters for implicit pointer handles for type: []*http.Cookie
func ptrFromHandle_Slice_Ptr_http_Cookie(h CGoHandle) *[]*http.Cookie {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*http.Cookie")
	if p == nil {
		return nil
	}
	return p.(*[]*http.Cookie)
}
func deptrFromHandle_Slice_Ptr_http_Cookie(h CGoHandle) []*http.Cookie {
	p := ptrFromHandle_Slice_Ptr_http_Cookie(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_http_Cookie(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*http.Cookie", p))
}

// --- wrapping slice: []*http.Cookie ---
//
//export Slice_Ptr_http_Cookie_CTor
func Slice_Ptr_http_Cookie_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_http_Cookie(&[]*http.Cookie{}))
}

//export Slice_Ptr_http_Cookie_len
func Slice_Ptr_http_Cookie_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_http_Cookie(handle))
}

//export Slice_Ptr_http_Cookie_elem
func Slice_Ptr_http_Cookie_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_http_Cookie(handle)
	return handleFromPtr_Ptr_http_Cookie(&(s[_idx]))
}

//export Slice_Ptr_http_Cookie_subslice
func Slice_Ptr_http_Cookie_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_http_Cookie(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_http_Cookie(&ss))
}

//export Slice_Ptr_http_Cookie_set
func Slice_Ptr_http_Cookie_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_http_Cookie(handle)
	s[_idx] = ptrFromHandle_Ptr_http_Cookie(_vl)
}

//export Slice_Ptr_http_Cookie_append
func Slice_Ptr_http_Cookie_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_http_Cookie(handle)
	*s = append(*s, ptrFromHandle_Ptr_http_Cookie(_vl))
}

// Converters for implicit pointer handles for type: []*url.URL
func ptrFromHandle_Slice_Ptr_url_URL(h CGoHandle) *[]*url.URL {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*url.URL")
	if p == nil {
		return nil
	}
	return p.(*[]*url.URL)
}
func deptrFromHandle_Slice_Ptr_url_URL(h CGoHandle) []*url.URL {
	p := ptrFromHandle_Slice_Ptr_url_URL(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_url_URL(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*url.URL", p))
}

// --- wrapping slice: []*url.URL ---
//
//export Slice_Ptr_url_URL_CTor
func Slice_Ptr_url_URL_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_url_URL(&[]*url.URL{}))
}

//export Slice_Ptr_url_URL_len
func Slice_Ptr_url_URL_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_url_URL(handle))
}

//export Slice_Ptr_url_URL_elem
func Slice_Ptr_url_URL_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_url_URL(handle)
	return handleFromPtr_Ptr_url_URL(&(s[_idx]))
}

//export Slice_Ptr_url_URL_subslice
func Slice_Ptr_url_URL_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_url_URL(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_url_URL(&ss))
}

//export Slice_Ptr_url_URL_set
func Slice_Ptr_url_URL_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_url_URL(handle)
	s[_idx] = ptrFromHandle_Ptr_url_URL(_vl)
}

//export Slice_Ptr_url_URL_append
func Slice_Ptr_url_URL_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_url_URL(handle)
	*s = append(*s, ptrFromHandle_Ptr_url_URL(_vl))
}

// Converters for implicit pointer handles for type: []BMXGo.ConvMessage
func ptrFromHandle_Slice_BMXGo_ConvMessage(h CGoHandle) *[]BMXGo.ConvMessage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]BMXGo.ConvMessage")
	if p == nil {
		return nil
	}
	return p.(*[]BMXGo.ConvMessage)
}
func deptrFromHandle_Slice_BMXGo_ConvMessage(h CGoHandle) []BMXGo.ConvMessage {
	p := ptrFromHandle_Slice_BMXGo_ConvMessage(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_BMXGo_ConvMessage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]BMXGo.ConvMessage", p))
}

// --- wrapping slice: []BMXGo.ConvMessage ---
//
//export Slice_BMXGo_ConvMessage_CTor
func Slice_BMXGo_ConvMessage_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_BMXGo_ConvMessage(&[]BMXGo.ConvMessage{}))
}

//export Slice_BMXGo_ConvMessage_len
func Slice_BMXGo_ConvMessage_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_BMXGo_ConvMessage(handle))
}

//export Slice_BMXGo_ConvMessage_elem
func Slice_BMXGo_ConvMessage_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_BMXGo_ConvMessage(handle)
	return handleFromPtr_BMXGo_ConvMessage(&(s[_idx]))
}

//export Slice_BMXGo_ConvMessage_subslice
func Slice_BMXGo_ConvMessage_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_BMXGo_ConvMessage(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_BMXGo_ConvMessage(&ss))
}

//export Slice_BMXGo_ConvMessage_set
func Slice_BMXGo_ConvMessage_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_BMXGo_ConvMessage(handle)
	s[_idx] = *ptrFromHandle_BMXGo_ConvMessage(_vl)
}

//export Slice_BMXGo_ConvMessage_append
func Slice_BMXGo_ConvMessage_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_BMXGo_ConvMessage(handle)
	*s = append(*s, *ptrFromHandle_BMXGo_ConvMessage(_vl))
}

// Converters for implicit pointer handles for type: []BMXGo.LinkedContent
func ptrFromHandle_Slice_BMXGo_LinkedContent(h CGoHandle) *[]BMXGo.LinkedContent {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]BMXGo.LinkedContent")
	if p == nil {
		return nil
	}
	return p.(*[]BMXGo.LinkedContent)
}
func deptrFromHandle_Slice_BMXGo_LinkedContent(h CGoHandle) []BMXGo.LinkedContent {
	p := ptrFromHandle_Slice_BMXGo_LinkedContent(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_BMXGo_LinkedContent(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]BMXGo.LinkedContent", p))
}

// --- wrapping slice: []BMXGo.LinkedContent ---
//
//export Slice_BMXGo_LinkedContent_CTor
func Slice_BMXGo_LinkedContent_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_BMXGo_LinkedContent(&[]BMXGo.LinkedContent{}))
}

//export Slice_BMXGo_LinkedContent_len
func Slice_BMXGo_LinkedContent_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_BMXGo_LinkedContent(handle))
}

//export Slice_BMXGo_LinkedContent_elem
func Slice_BMXGo_LinkedContent_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_BMXGo_LinkedContent(handle)
	return handleFromPtr_BMXGo_LinkedContent(&(s[_idx]))
}

//export Slice_BMXGo_LinkedContent_subslice
func Slice_BMXGo_LinkedContent_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_BMXGo_LinkedContent(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_BMXGo_LinkedContent(&ss))
}

//export Slice_BMXGo_LinkedContent_set
func Slice_BMXGo_LinkedContent_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_BMXGo_LinkedContent(handle)
	s[_idx] = *ptrFromHandle_BMXGo_LinkedContent(_vl)
}

//export Slice_BMXGo_LinkedContent_append
func Slice_BMXGo_LinkedContent_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_BMXGo_LinkedContent(handle)
	*s = append(*s, *ptrFromHandle_BMXGo_LinkedContent(_vl))
}

// Converters for implicit pointer handles for type: []BMXGo.SearchResults
func ptrFromHandle_Slice_BMXGo_SearchResults(h CGoHandle) *[]BMXGo.SearchResults {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]BMXGo.SearchResults")
	if p == nil {
		return nil
	}
	return p.(*[]BMXGo.SearchResults)
}
func deptrFromHandle_Slice_BMXGo_SearchResults(h CGoHandle) []BMXGo.SearchResults {
	p := ptrFromHandle_Slice_BMXGo_SearchResults(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_BMXGo_SearchResults(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]BMXGo.SearchResults", p))
}

// --- wrapping slice: []BMXGo.SearchResults ---
//
//export Slice_BMXGo_SearchResults_CTor
func Slice_BMXGo_SearchResults_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_BMXGo_SearchResults(&[]BMXGo.SearchResults{}))
}

//export Slice_BMXGo_SearchResults_len
func Slice_BMXGo_SearchResults_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_BMXGo_SearchResults(handle))
}

//export Slice_BMXGo_SearchResults_elem
func Slice_BMXGo_SearchResults_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_BMXGo_SearchResults(handle)
	return handleFromPtr_BMXGo_SearchResults(&(s[_idx]))
}

//export Slice_BMXGo_SearchResults_subslice
func Slice_BMXGo_SearchResults_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_BMXGo_SearchResults(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_BMXGo_SearchResults(&ss))
}

//export Slice_BMXGo_SearchResults_set
func Slice_BMXGo_SearchResults_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_BMXGo_SearchResults(handle)
	s[_idx] = *ptrFromHandle_BMXGo_SearchResults(_vl)
}

//export Slice_BMXGo_SearchResults_append
func Slice_BMXGo_SearchResults_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_BMXGo_SearchResults(handle)
	*s = append(*s, *ptrFromHandle_BMXGo_SearchResults(_vl))
}

// Converters for implicit pointer handles for type: [][]*x509.Certificate
func ptrFromHandle_Slice_Slice_Ptr_x509_Certificate(h CGoHandle) *[][]*x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]*x509.Certificate")
	if p == nil {
		return nil
	}
	return p.(*[][]*x509.Certificate)
}
func deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(h CGoHandle) [][]*x509.Certificate {
	p := ptrFromHandle_Slice_Slice_Ptr_x509_Certificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_Ptr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]*x509.Certificate", p))
}

// --- wrapping slice: [][]*x509.Certificate ---
//
//export Slice_Slice_Ptr_x509_Certificate_CTor
func Slice_Slice_Ptr_x509_Certificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_Ptr_x509_Certificate(&[][]*x509.Certificate{}))
}

//export Slice_Slice_Ptr_x509_Certificate_len
func Slice_Slice_Ptr_x509_Certificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle))
}

//export Slice_Slice_Ptr_x509_Certificate_elem
func Slice_Slice_Ptr_x509_Certificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	return handleFromPtr_Slice_Ptr_x509_Certificate(&(s[_idx]))
}

//export Slice_Slice_Ptr_x509_Certificate_subslice
func Slice_Slice_Ptr_x509_Certificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_Ptr_x509_Certificate(&ss))
}

//export Slice_Slice_Ptr_x509_Certificate_set
func Slice_Slice_Ptr_x509_Certificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	s[_idx] = deptrFromHandle_Slice_Ptr_x509_Certificate(_vl)
}

//export Slice_Slice_Ptr_x509_Certificate_append
func Slice_Slice_Ptr_x509_Certificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	*s = append(*s, deptrFromHandle_Slice_Ptr_x509_Certificate(_vl))
}

// Converters for implicit pointer handles for type: [][]byte
func ptrFromHandle_Slice_Slice_byte(h CGoHandle) *[][]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]byte")
	if p == nil {
		return nil
	}
	return p.(*[][]byte)
}
func deptrFromHandle_Slice_Slice_byte(h CGoHandle) [][]byte {
	p := ptrFromHandle_Slice_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]byte", p))
}

// --- wrapping slice: [][]byte ---
//
//export Slice_Slice_byte_CTor
func Slice_Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&[][]byte{}))
}

//export Slice_Slice_byte_len
func Slice_Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_byte(handle))
}

//export Slice_Slice_byte_elem
func Slice_Slice_byte_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	return handleFromPtr_Slice_byte(&(s[_idx]))
}

//export Slice_Slice_byte_subslice
func Slice_Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&ss))
}

//export Slice_Slice_byte_set
func Slice_Slice_byte_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	s[_idx] = deptrFromHandle_Slice_byte(_vl)
}

//export Slice_Slice_byte_append
func Slice_Slice_byte_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_byte(handle)
	*s = append(*s, deptrFromHandle_Slice_byte(_vl))
}

// Converters for implicit pointer handles for type: [][]string
func ptrFromHandle_Slice_Slice_string(h CGoHandle) *[][]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]string")
	if p == nil {
		return nil
	}
	return p.(*[][]string)
}
func deptrFromHandle_Slice_Slice_string(h CGoHandle) [][]string {
	p := ptrFromHandle_Slice_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]string", p))
}

// --- wrapping slice: [][]string ---
//
//export Slice_Slice_string_CTor
func Slice_Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_string(&[][]string{}))
}

//export Slice_Slice_string_len
func Slice_Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_string(handle))
}

//export Slice_Slice_string_elem
func Slice_Slice_string_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_string(handle)
	return handleFromPtr_Slice_string(&(s[_idx]))
}

//export Slice_Slice_string_subslice
func Slice_Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_string(&ss))
}

//export Slice_Slice_string_set
func Slice_Slice_string_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_string(handle)
	s[_idx] = deptrFromHandle_Slice_string(_vl)
}

//export Slice_Slice_string_append
func Slice_Slice_string_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_string(handle)
	*s = append(*s, deptrFromHandle_Slice_string(_vl))
}

// Converters for implicit pointer handles for type: []x509.ExtKeyUsage
func ptrFromHandle_Slice_x509_ExtKeyUsage(h CGoHandle) *[]x509.ExtKeyUsage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]x509.ExtKeyUsage")
	if p == nil {
		return nil
	}
	return p.(*[]x509.ExtKeyUsage)
}
func deptrFromHandle_Slice_x509_ExtKeyUsage(h CGoHandle) []x509.ExtKeyUsage {
	p := ptrFromHandle_Slice_x509_ExtKeyUsage(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_x509_ExtKeyUsage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]x509.ExtKeyUsage", p))
}

// --- wrapping slice: []x509.ExtKeyUsage ---
//
//export Slice_x509_ExtKeyUsage_CTor
func Slice_x509_ExtKeyUsage_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_x509_ExtKeyUsage(&[]x509.ExtKeyUsage{}))
}

//export Slice_x509_ExtKeyUsage_len
func Slice_x509_ExtKeyUsage_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_x509_ExtKeyUsage(handle))
}

//export Slice_x509_ExtKeyUsage_elem
func Slice_x509_ExtKeyUsage_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	return C.longlong(int(s[_idx]))
}

//export Slice_x509_ExtKeyUsage_subslice
func Slice_x509_ExtKeyUsage_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_x509_ExtKeyUsage(&ss))
}

//export Slice_x509_ExtKeyUsage_set
func Slice_x509_ExtKeyUsage_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	s[_idx] = x509.ExtKeyUsage(int(_vl))
}

//export Slice_x509_ExtKeyUsage_append
func Slice_x509_ExtKeyUsage_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	*s = append(*s, x509.ExtKeyUsage(int(_vl)))
}

// Converters for implicit pointer handles for type: []x509.OID
func ptrFromHandle_Slice_x509_OID(h CGoHandle) *[]x509.OID {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]x509.OID")
	if p == nil {
		return nil
	}
	return p.(*[]x509.OID)
}
func deptrFromHandle_Slice_x509_OID(h CGoHandle) []x509.OID {
	p := ptrFromHandle_Slice_x509_OID(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_x509_OID(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]x509.OID", p))
}

// --- wrapping slice: []x509.OID ---
//
//export Slice_x509_OID_CTor
func Slice_x509_OID_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_x509_OID(&[]x509.OID{}))
}

//export Slice_x509_OID_len
func Slice_x509_OID_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_x509_OID(handle))
}

//export Slice_x509_OID_elem
func Slice_x509_OID_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_x509_OID(handle)
	return handleFromPtr_x509_OID(&(s[_idx]))
}

//export Slice_x509_OID_subslice
func Slice_x509_OID_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_x509_OID(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_x509_OID(&ss))
}

//export Slice_x509_OID_set
func Slice_x509_OID_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_x509_OID(handle)
	s[_idx] = *ptrFromHandle_x509_OID(_vl)
}

//export Slice_x509_OID_append
func Slice_x509_OID_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_x509_OID(handle)
	*s = append(*s, *ptrFromHandle_x509_OID(_vl))
}

// Converters for implicit pointer handles for type: []pkix.AttributeTypeAndValue
func ptrFromHandle_Slice_pkix_AttributeTypeAndValue(h CGoHandle) *[]pkix.AttributeTypeAndValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pkix.AttributeTypeAndValue")
	if p == nil {
		return nil
	}
	return p.(*[]pkix.AttributeTypeAndValue)
}
func deptrFromHandle_Slice_pkix_AttributeTypeAndValue(h CGoHandle) []pkix.AttributeTypeAndValue {
	p := ptrFromHandle_Slice_pkix_AttributeTypeAndValue(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pkix_AttributeTypeAndValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pkix.AttributeTypeAndValue", p))
}

// --- wrapping slice: []pkix.AttributeTypeAndValue ---
//
//export Slice_pkix_AttributeTypeAndValue_CTor
func Slice_pkix_AttributeTypeAndValue_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pkix_AttributeTypeAndValue(&[]pkix.AttributeTypeAndValue{}))
}

//export Slice_pkix_AttributeTypeAndValue_len
func Slice_pkix_AttributeTypeAndValue_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle))
}

//export Slice_pkix_AttributeTypeAndValue_elem
func Slice_pkix_AttributeTypeAndValue_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	return handleFromPtr_pkix_AttributeTypeAndValue(&(s[_idx]))
}

//export Slice_pkix_AttributeTypeAndValue_subslice
func Slice_pkix_AttributeTypeAndValue_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pkix_AttributeTypeAndValue(&ss))
}

//export Slice_pkix_AttributeTypeAndValue_set
func Slice_pkix_AttributeTypeAndValue_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	s[_idx] = *ptrFromHandle_pkix_AttributeTypeAndValue(_vl)
}

//export Slice_pkix_AttributeTypeAndValue_append
func Slice_pkix_AttributeTypeAndValue_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	*s = append(*s, *ptrFromHandle_pkix_AttributeTypeAndValue(_vl))
}

// Converters for implicit pointer handles for type: []pkix.Extension
func ptrFromHandle_Slice_pkix_Extension(h CGoHandle) *[]pkix.Extension {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pkix.Extension")
	if p == nil {
		return nil
	}
	return p.(*[]pkix.Extension)
}
func deptrFromHandle_Slice_pkix_Extension(h CGoHandle) []pkix.Extension {
	p := ptrFromHandle_Slice_pkix_Extension(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pkix_Extension(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pkix.Extension", p))
}

// --- wrapping slice: []pkix.Extension ---
//
//export Slice_pkix_Extension_CTor
func Slice_pkix_Extension_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pkix_Extension(&[]pkix.Extension{}))
}

//export Slice_pkix_Extension_len
func Slice_pkix_Extension_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pkix_Extension(handle))
}

//export Slice_pkix_Extension_elem
func Slice_pkix_Extension_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_Extension(handle)
	return handleFromPtr_pkix_Extension(&(s[_idx]))
}

//export Slice_pkix_Extension_subslice
func Slice_pkix_Extension_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_Extension(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pkix_Extension(&ss))
}

//export Slice_pkix_Extension_set
func Slice_pkix_Extension_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pkix_Extension(handle)
	s[_idx] = *ptrFromHandle_pkix_Extension(_vl)
}

//export Slice_pkix_Extension_append
func Slice_pkix_Extension_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pkix_Extension(handle)
	*s = append(*s, *ptrFromHandle_pkix_Extension(_vl))
}

// Converters for implicit pointer handles for type: []pkix.RevokedCertificate
func ptrFromHandle_Slice_pkix_RevokedCertificate(h CGoHandle) *[]pkix.RevokedCertificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pkix.RevokedCertificate")
	if p == nil {
		return nil
	}
	return p.(*[]pkix.RevokedCertificate)
}
func deptrFromHandle_Slice_pkix_RevokedCertificate(h CGoHandle) []pkix.RevokedCertificate {
	p := ptrFromHandle_Slice_pkix_RevokedCertificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pkix_RevokedCertificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pkix.RevokedCertificate", p))
}

// --- wrapping slice: []pkix.RevokedCertificate ---
//
//export Slice_pkix_RevokedCertificate_CTor
func Slice_pkix_RevokedCertificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pkix_RevokedCertificate(&[]pkix.RevokedCertificate{}))
}

//export Slice_pkix_RevokedCertificate_len
func Slice_pkix_RevokedCertificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pkix_RevokedCertificate(handle))
}

//export Slice_pkix_RevokedCertificate_elem
func Slice_pkix_RevokedCertificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	return handleFromPtr_pkix_RevokedCertificate(&(s[_idx]))
}

//export Slice_pkix_RevokedCertificate_subslice
func Slice_pkix_RevokedCertificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pkix_RevokedCertificate(&ss))
}

//export Slice_pkix_RevokedCertificate_set
func Slice_pkix_RevokedCertificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	s[_idx] = *ptrFromHandle_pkix_RevokedCertificate(_vl)
}

//export Slice_pkix_RevokedCertificate_append
func Slice_pkix_RevokedCertificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	*s = append(*s, *ptrFromHandle_pkix_RevokedCertificate(_vl))
}

// Converters for implicit pointer handles for type: []asn1.ObjectIdentifier
func ptrFromHandle_Slice_asn1_ObjectIdentifier(h CGoHandle) *[]asn1.ObjectIdentifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]asn1.ObjectIdentifier")
	if p == nil {
		return nil
	}
	return p.(*[]asn1.ObjectIdentifier)
}
func deptrFromHandle_Slice_asn1_ObjectIdentifier(h CGoHandle) []asn1.ObjectIdentifier {
	p := ptrFromHandle_Slice_asn1_ObjectIdentifier(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_asn1_ObjectIdentifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]asn1.ObjectIdentifier", p))
}

// --- wrapping slice: []asn1.ObjectIdentifier ---
//
//export Slice_asn1_ObjectIdentifier_CTor
func Slice_asn1_ObjectIdentifier_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_asn1_ObjectIdentifier(&[]asn1.ObjectIdentifier{}))
}

//export Slice_asn1_ObjectIdentifier_len
func Slice_asn1_ObjectIdentifier_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_asn1_ObjectIdentifier(handle))
}

//export Slice_asn1_ObjectIdentifier_elem
func Slice_asn1_ObjectIdentifier_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	return handleFromPtr_asn1_ObjectIdentifier(&(s[_idx]))
}

//export Slice_asn1_ObjectIdentifier_subslice
func Slice_asn1_ObjectIdentifier_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_asn1_ObjectIdentifier(&ss))
}

//export Slice_asn1_ObjectIdentifier_set
func Slice_asn1_ObjectIdentifier_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	s[_idx] = deptrFromHandle_asn1_ObjectIdentifier(_vl)
}

//export Slice_asn1_ObjectIdentifier_append
func Slice_asn1_ObjectIdentifier_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	*s = append(*s, deptrFromHandle_asn1_ObjectIdentifier(_vl))
}

// Converters for implicit pointer handles for type: []big.Word
func ptrFromHandle_Slice_big_Word(h CGoHandle) *[]big.Word {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]big.Word")
	if p == nil {
		return nil
	}
	return p.(*[]big.Word)
}
func deptrFromHandle_Slice_big_Word(h CGoHandle) []big.Word {
	p := ptrFromHandle_Slice_big_Word(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_big_Word(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]big.Word", p))
}

// --- wrapping slice: []big.Word ---
//
//export Slice_big_Word_CTor
func Slice_big_Word_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_big_Word(&[]big.Word{}))
}

//export Slice_big_Word_len
func Slice_big_Word_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_big_Word(handle))
}

//export Slice_big_Word_elem
func Slice_big_Word_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_big_Word(handle)
	return C.ulonglong(uint(s[_idx]))
}

//export Slice_big_Word_subslice
func Slice_big_Word_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_big_Word(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_big_Word(&ss))
}

//export Slice_big_Word_set
func Slice_big_Word_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_big_Word(handle)
	s[_idx] = big.Word(uint(_vl))
}

//export Slice_big_Word_append
func Slice_big_Word_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_big_Word(handle)
	*s = append(*s, big.Word(uint(_vl)))
}

// Converters for implicit pointer handles for type: []net.IP
func ptrFromHandle_Slice_net_IP(h CGoHandle) *[]net.IP {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]net.IP")
	if p == nil {
		return nil
	}
	return p.(*[]net.IP)
}
func deptrFromHandle_Slice_net_IP(h CGoHandle) []net.IP {
	p := ptrFromHandle_Slice_net_IP(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_net_IP(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]net.IP", p))
}

// --- wrapping slice: []net.IP ---
//
//export Slice_net_IP_CTor
func Slice_net_IP_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_net_IP(&[]net.IP{}))
}

//export Slice_net_IP_len
func Slice_net_IP_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_net_IP(handle))
}

//export Slice_net_IP_elem
func Slice_net_IP_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_net_IP(handle)
	return handleFromPtr_net_IP(&(s[_idx]))
}

//export Slice_net_IP_subslice
func Slice_net_IP_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_net_IP(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_net_IP(&ss))
}

//export Slice_net_IP_set
func Slice_net_IP_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_net_IP(handle)
	s[_idx] = deptrFromHandle_net_IP(_vl)
}

//export Slice_net_IP_append
func Slice_net_IP_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_net_IP(handle)
	*s = append(*s, deptrFromHandle_net_IP(_vl))
}

// Converters for pointer handles for type: any
func ptrFromHandle_any(h CGoHandle) any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "any")
	if p == nil {
		return nil
	}
	return p.(any)
}
func handleFromPtr_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("any", p))
}

// Converters for implicit pointer handles for type: map[string]BMXGo.Document
func ptrFromHandle_Map_string_BMXGo_Document(h CGoHandle) *map[string]BMXGo.Document {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]BMXGo.Document")
	if p == nil {
		return nil
	}
	return p.(*map[string]BMXGo.Document)
}
func deptrFromHandle_Map_string_BMXGo_Document(h CGoHandle) map[string]BMXGo.Document {
	p := ptrFromHandle_Map_string_BMXGo_Document(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_BMXGo_Document(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]BMXGo.Document", p))
}

// --- wrapping map: map[string]BMXGo.Document ---
//
//export Map_string_BMXGo_Document_CTor
func Map_string_BMXGo_Document_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_BMXGo_Document(&map[string]BMXGo.Document{}))
}

//export Map_string_BMXGo_Document_len
func Map_string_BMXGo_Document_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_BMXGo_Document(handle))
}

//export Map_string_BMXGo_Document_elem
func Map_string_BMXGo_Document_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_BMXGo_Document(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_BMXGo_Document(&v)
}

//export Map_string_BMXGo_Document_contains
func Map_string_BMXGo_Document_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_BMXGo_Document(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_BMXGo_Document_set
func Map_string_BMXGo_Document_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_BMXGo_Document(handle)
	s[C.GoString(_ky)] = *ptrFromHandle_BMXGo_Document(_vl)
}

//export Map_string_BMXGo_Document_delete
func Map_string_BMXGo_Document_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_BMXGo_Document(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_BMXGo_Document_keys
func Map_string_BMXGo_Document_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_BMXGo_Document(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string][]*multipart.FileHeader
func ptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(h CGoHandle) *map[string][]*multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string][]*multipart.FileHeader")
	if p == nil {
		return nil
	}
	return p.(*map[string][]*multipart.FileHeader)
}
func deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(h CGoHandle) map[string][]*multipart.FileHeader {
	p := ptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Slice_Ptr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string][]*multipart.FileHeader", p))
}

// --- wrapping map: map[string][]*multipart.FileHeader ---
//
//export Map_string_Slice_Ptr_multipart_FileHeader_CTor
func Map_string_Slice_Ptr_multipart_FileHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Slice_Ptr_multipart_FileHeader(&map[string][]*multipart.FileHeader{}))
}

//export Map_string_Slice_Ptr_multipart_FileHeader_len
func Map_string_Slice_Ptr_multipart_FileHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle))
}

//export Map_string_Slice_Ptr_multipart_FileHeader_elem
func Map_string_Slice_Ptr_multipart_FileHeader_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_Ptr_multipart_FileHeader(&v)
}

//export Map_string_Slice_Ptr_multipart_FileHeader_contains
func Map_string_Slice_Ptr_multipart_FileHeader_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Slice_Ptr_multipart_FileHeader_set
func Map_string_Slice_Ptr_multipart_FileHeader_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_Ptr_multipart_FileHeader(_vl)
}

//export Map_string_Slice_Ptr_multipart_FileHeader_delete
func Map_string_Slice_Ptr_multipart_FileHeader_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Slice_Ptr_multipart_FileHeader_keys
func Map_string_Slice_Ptr_multipart_FileHeader_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string][]string
func ptrFromHandle_Map_string_Slice_string(h CGoHandle) *map[string][]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string][]string")
	if p == nil {
		return nil
	}
	return p.(*map[string][]string)
}
func deptrFromHandle_Map_string_Slice_string(h CGoHandle) map[string][]string {
	p := ptrFromHandle_Map_string_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string][]string", p))
}

// --- wrapping map: map[string][]string ---
//
//export Map_string_Slice_string_CTor
func Map_string_Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Slice_string(&map[string][]string{}))
}

//export Map_string_Slice_string_len
func Map_string_Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Slice_string(handle))
}

//export Map_string_Slice_string_elem
func Map_string_Slice_string_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export Map_string_Slice_string_contains
func Map_string_Slice_string_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Slice_string_set
func Map_string_Slice_string_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export Map_string_Slice_string_delete
func Map_string_Slice_string_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Slice_string_keys
func Map_string_Slice_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]bool
func ptrFromHandle_Map_string_bool(h CGoHandle) *map[string]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]bool")
	if p == nil {
		return nil
	}
	return p.(*map[string]bool)
}
func deptrFromHandle_Map_string_bool(h CGoHandle) map[string]bool {
	p := ptrFromHandle_Map_string_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]bool", p))
}

// --- wrapping map: map[string]bool ---
//
//export Map_string_bool_CTor
func Map_string_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_bool(&map[string]bool{}))
}

//export Map_string_bool_len
func Map_string_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_bool(handle))
}

//export Map_string_bool_elem
func Map_string_bool_elem(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_bool(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return boolGoToPy(v)
}

//export Map_string_bool_contains
func Map_string_bool_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_bool(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_bool_set
func Map_string_bool_set(handle CGoHandle, _ky *C.char, _vl C.char) {
	s := deptrFromHandle_Map_string_bool(handle)
	s[C.GoString(_ky)] = boolPyToGo(_vl)
}

//export Map_string_bool_delete
func Map_string_bool_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_bool(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_bool_keys
func Map_string_bool_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_bool(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]float64
func ptrFromHandle_Map_string_float64(h CGoHandle) *map[string]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]float64")
	if p == nil {
		return nil
	}
	return p.(*map[string]float64)
}
func deptrFromHandle_Map_string_float64(h CGoHandle) map[string]float64 {
	p := ptrFromHandle_Map_string_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]float64", p))
}

// --- wrapping map: map[string]float64 ---
//
//export Map_string_float64_CTor
func Map_string_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_float64(&map[string]float64{}))
}

//export Map_string_float64_len
func Map_string_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_float64(handle))
}

//export Map_string_float64_elem
func Map_string_float64_elem(handle CGoHandle, _ky *C.char) C.double {
	s := deptrFromHandle_Map_string_float64(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.double(v)
}

//export Map_string_float64_contains
func Map_string_float64_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_float64(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_float64_set
func Map_string_float64_set(handle CGoHandle, _ky *C.char, _vl C.double) {
	s := deptrFromHandle_Map_string_float64(handle)
	s[C.GoString(_ky)] = float64(_vl)
}

//export Map_string_float64_delete
func Map_string_float64_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_float64(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_float64_keys
func Map_string_float64_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_float64(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]int
func ptrFromHandle_Map_string_int(h CGoHandle) *map[string]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]int")
	if p == nil {
		return nil
	}
	return p.(*map[string]int)
}
func deptrFromHandle_Map_string_int(h CGoHandle) map[string]int {
	p := ptrFromHandle_Map_string_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]int", p))
}

// --- wrapping map: map[string]int ---
//
//export Map_string_int_CTor
func Map_string_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_int(&map[string]int{}))
}

//export Map_string_int_len
func Map_string_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_int(handle))
}

//export Map_string_int_elem
func Map_string_int_elem(handle CGoHandle, _ky *C.char) C.longlong {
	s := deptrFromHandle_Map_string_int(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.longlong(v)
}

//export Map_string_int_contains
func Map_string_int_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_int(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_int_set
func Map_string_int_set(handle CGoHandle, _ky *C.char, _vl C.longlong) {
	s := deptrFromHandle_Map_string_int(handle)
	s[C.GoString(_ky)] = int(_vl)
}

//export Map_string_int_delete
func Map_string_int_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_int(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_int_keys
func Map_string_int_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_int(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: BMXGo.Parameters ---
//
//export BMXGo_Parameters_CTor
func BMXGo_Parameters_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_BMXGo_Parameters(&BMXGo.Parameters{}))
}

//export BMXGo_Parameters_Alpha_Get
func BMXGo_Parameters_Alpha_Get(handle CGoHandle) C.double {
	op := ptrFromHandle_BMXGo_Parameters(handle)
	return C.double(op.Alpha)
}

//export BMXGo_Parameters_Alpha_Set
func BMXGo_Parameters_Alpha_Set(handle CGoHandle, val C.double) {
	op := ptrFromHandle_BMXGo_Parameters(handle)
	op.Alpha = float64(val)
}

//export BMXGo_Parameters_Beta_Get
func BMXGo_Parameters_Beta_Get(handle CGoHandle) C.double {
	op := ptrFromHandle_BMXGo_Parameters(handle)
	return C.double(op.Beta)
}

//export BMXGo_Parameters_Beta_Set
func BMXGo_Parameters_Beta_Set(handle CGoHandle, val C.double) {
	op := ptrFromHandle_BMXGo_Parameters(handle)
	op.Beta = float64(val)
}

//export BMXGo_Parameters_Avgdl_Get
func BMXGo_Parameters_Avgdl_Get(handle CGoHandle) C.double {
	op := ptrFromHandle_BMXGo_Parameters(handle)
	return C.double(op.Avgdl)
}

//export BMXGo_Parameters_Avgdl_Set
func BMXGo_Parameters_Avgdl_Set(handle CGoHandle, val C.double) {
	op := ptrFromHandle_BMXGo_Parameters(handle)
	op.Avgdl = float64(val)
}

//export BMXGo_Parameters_N_Get
func BMXGo_Parameters_N_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_BMXGo_Parameters(handle)
	return C.longlong(op.N)
}

//export BMXGo_Parameters_N_Set
func BMXGo_Parameters_N_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_BMXGo_Parameters(handle)
	op.N = int(val)
}

// --- wrapping struct: BMXGo.Query ---
//
//export BMXGo_Query_CTor
func BMXGo_Query_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_BMXGo_Query(&BMXGo.Query{}))
}

//export BMXGo_Query_Text_Get
func BMXGo_Query_Text_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_BMXGo_Query(handle)
	return C.CString(op.Text)
}

//export BMXGo_Query_Text_Set
func BMXGo_Query_Text_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_BMXGo_Query(handle)
	op.Text = C.GoString(val)
}

//export BMXGo_Query_Tokens_Get
func BMXGo_Query_Tokens_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_Query(handle)
	return handleFromPtr_Map_string_float64(&op.Tokens)
}

//export BMXGo_Query_Tokens_Set
func BMXGo_Query_Tokens_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_Query(handle)
	op.Tokens = deptrFromHandle_Map_string_float64(val)
}

//export BMXGo_Query_TotalWeight_Get
func BMXGo_Query_TotalWeight_Get(handle CGoHandle) C.double {
	op := ptrFromHandle_BMXGo_Query(handle)
	return C.double(op.TotalWeight)
}

//export BMXGo_Query_TotalWeight_Set
func BMXGo_Query_TotalWeight_Set(handle CGoHandle, val C.double) {
	op := ptrFromHandle_BMXGo_Query(handle)
	op.TotalWeight = float64(val)
}

//export BMXGo_Query_S_table_Get
func BMXGo_Query_S_table_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_Query(handle)
	return handleFromPtr_Map_string_float64(&op.S_table)
}

//export BMXGo_Query_S_table_Set
func BMXGo_Query_S_table_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_Query(handle)
	op.S_table = deptrFromHandle_Map_string_float64(val)
}

//export BMXGo_Query_ScoreTable_Get
func BMXGo_Query_ScoreTable_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_Query(handle)
	return handleFromPtr_Map_string_float64(&op.ScoreTable)
}

//export BMXGo_Query_ScoreTable_Set
func BMXGo_Query_ScoreTable_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_Query(handle)
	op.ScoreTable = deptrFromHandle_Map_string_float64(val)
}

//export BMXGo_Query_NormalizedScoreTable_Get
func BMXGo_Query_NormalizedScoreTable_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_Query(handle)
	return handleFromPtr_Map_string_float64(&op.NormalizedScoreTable)
}

//export BMXGo_Query_NormalizedScoreTable_Set
func BMXGo_Query_NormalizedScoreTable_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_Query(handle)
	op.NormalizedScoreTable = deptrFromHandle_Map_string_float64(val)
}

//export BMXGo_Query_AugmentedQueries_Get
func BMXGo_Query_AugmentedQueries_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_Query(handle)
	return handleFromPtr_Slice_string(&op.AugmentedQueries)
}

//export BMXGo_Query_AugmentedQueries_Set
func BMXGo_Query_AugmentedQueries_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_Query(handle)
	op.AugmentedQueries = deptrFromHandle_Slice_string(val)
}

//export BMXGo_Query_AugmentedWeights_Get
func BMXGo_Query_AugmentedWeights_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_Query(handle)
	return handleFromPtr_Slice_float64(&op.AugmentedWeights)
}

//export BMXGo_Query_AugmentedWeights_Set
func BMXGo_Query_AugmentedWeights_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_Query(handle)
	op.AugmentedWeights = deptrFromHandle_Slice_float64(val)
}

//export BMXGo_Query_SetEntropy
func BMXGo_Query_SetEntropy(_handle CGoHandle, bmx CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.Query")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(BMXGo.Query{})).(*BMXGo.Query).SetEntropy(ptrFromHandle_Ptr_BMXGo_BMX(bmx))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(BMXGo.Query{})).(*BMXGo.Query).SetEntropy(ptrFromHandle_Ptr_BMXGo_BMX(bmx))
	}
}

//export BMXGo_Query_S_table_fill
func BMXGo_Query_S_table_fill(_handle CGoHandle, bmx CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.Query")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(BMXGo.Query{})).(*BMXGo.Query).S_table_fill(ptrFromHandle_Ptr_BMXGo_BMX(bmx))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(BMXGo.Query{})).(*BMXGo.Query).S_table_fill(ptrFromHandle_Ptr_BMXGo_BMX(bmx))
	}
}

//export BMXGo_Query_Score_table_fill
func BMXGo_Query_Score_table_fill(_handle CGoHandle, bmx CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.Query")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(BMXGo.Query{})).(*BMXGo.Query).Score_table_fill(ptrFromHandle_Ptr_BMXGo_BMX(bmx))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(BMXGo.Query{})).(*BMXGo.Query).Score_table_fill(ptrFromHandle_Ptr_BMXGo_BMX(bmx))
	}
}

//export BMXGo_Query_NormalizedScore_table_fill
func BMXGo_Query_NormalizedScore_table_fill(_handle CGoHandle, bmx CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.Query")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(BMXGo.Query{})).(*BMXGo.Query).NormalizedScore_table_fill(ptrFromHandle_Ptr_BMXGo_BMX(bmx))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(BMXGo.Query{})).(*BMXGo.Query).NormalizedScore_table_fill(ptrFromHandle_Ptr_BMXGo_BMX(bmx))
	}
}

//export BMXGo_Query_Initialize
func BMXGo_Query_Initialize(_handle CGoHandle, bmx CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.Query")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(BMXGo.Query{})).(*BMXGo.Query).Initialize(ptrFromHandle_Ptr_BMXGo_BMX(bmx))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(BMXGo.Query{})).(*BMXGo.Query).Initialize(ptrFromHandle_Ptr_BMXGo_BMX(bmx))
	}
}

//export BMXGo_Query_Rank
func BMXGo_Query_Rank(_handle CGoHandle, topK C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.Query")
	if __err != nil {
		return handleFromPtr_Slice_string(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(BMXGo.Query{})).(*BMXGo.Query).Rank(int(topK))

	return handleFromPtr_Slice_string(&cret)
}

// --- wrapping struct: BMXGo.SearchResults ---
//
//export BMXGo_SearchResults_CTor
func BMXGo_SearchResults_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_BMXGo_SearchResults(&BMXGo.SearchResults{}))
}

//export BMXGo_SearchResults_Keys_Get
func BMXGo_SearchResults_Keys_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_SearchResults(handle)
	return handleFromPtr_Slice_string(&op.Keys)
}

//export BMXGo_SearchResults_Keys_Set
func BMXGo_SearchResults_Keys_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_SearchResults(handle)
	op.Keys = deptrFromHandle_Slice_string(val)
}

//export BMXGo_SearchResults_Scores_Get
func BMXGo_SearchResults_Scores_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_SearchResults(handle)
	return handleFromPtr_Slice_float64(&op.Scores)
}

//export BMXGo_SearchResults_Scores_Set
func BMXGo_SearchResults_Scores_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_SearchResults(handle)
	op.Scores = deptrFromHandle_Slice_float64(val)
}

// --- wrapping struct: BMXGo.BMX ---
//
//export BMXGo_BMX_CTor
func BMXGo_BMX_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_BMXGo_BMX(&BMXGo.BMX{}))
}

//export BMXGo_BMX_Docs_Get
func BMXGo_BMX_Docs_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_BMX(handle)
	return handleFromPtr_Map_string_BMXGo_Document(&op.Docs)
}

//export BMXGo_BMX_Docs_Set
func BMXGo_BMX_Docs_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_BMX(handle)
	op.Docs = deptrFromHandle_Map_string_BMXGo_Document(val)
}

//export BMXGo_BMX_Params_Get
func BMXGo_BMX_Params_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_BMX(handle)
	return handleFromPtr_BMXGo_Parameters(&op.Params)
}

//export BMXGo_BMX_Params_Set
func BMXGo_BMX_Params_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_BMX(handle)
	op.Params = *ptrFromHandle_BMXGo_Parameters(val)
}

//export BMXGo_BMX_TextPreprocessor_Get
func BMXGo_BMX_TextPreprocessor_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_BMX(handle)
	return handleFromPtr_Ptr_BMXGo_TextPreprocessor(op.TextPreprocessor)
}

//export BMXGo_BMX_TextPreprocessor_Set
func BMXGo_BMX_TextPreprocessor_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_BMX(handle)
	op.TextPreprocessor = ptrFromHandle_Ptr_BMXGo_TextPreprocessor(val)
}

//export BMXGo_BMX_NumAppearances_Get
func BMXGo_BMX_NumAppearances_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_BMX(handle)
	return handleFromPtr_Map_string_Slice_string(&op.NumAppearances)
}

//export BMXGo_BMX_NumAppearances_Set
func BMXGo_BMX_NumAppearances_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_BMX(handle)
	op.NumAppearances = deptrFromHandle_Map_string_Slice_string(val)
}

//export BMXGo_BMX_IDF_table_Get
func BMXGo_BMX_IDF_table_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_BMX(handle)
	return handleFromPtr_Map_string_float64(&op.IDF_table)
}

//export BMXGo_BMX_IDF_table_Set
func BMXGo_BMX_IDF_table_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_BMX(handle)
	op.IDF_table = deptrFromHandle_Map_string_float64(val)
}

//export BMXGo_BMX_E_tilde_table_Get
func BMXGo_BMX_E_tilde_table_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_BMX(handle)
	return handleFromPtr_Map_string_float64(&op.E_tilde_table)
}

//export BMXGo_BMX_E_tilde_table_Set
func BMXGo_BMX_E_tilde_table_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_BMX(handle)
	op.E_tilde_table = deptrFromHandle_Map_string_float64(val)
}

//export BMXGo_BMX_InitializeTextPreprocessor
func BMXGo_BMX_InitializeTextPreprocessor(_handle CGoHandle, config CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.BMX")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMX{})).(*BMXGo.BMX).InitializeTextPreprocessor(ptrFromHandle_Ptr_BMXGo_Config(config))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export BMXGo_BMX_SetParams
func BMXGo_BMX_SetParams(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.BMX")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMX{})).(*BMXGo.BMX).SetParams()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMX{})).(*BMXGo.BMX).SetParams()
	}
}

//export BMXGo_BMX_F_table_fill
func BMXGo_BMX_F_table_fill(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.BMX")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMX{})).(*BMXGo.BMX).F_table_fill()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMX{})).(*BMXGo.BMX).F_table_fill()
	}
}

//export BMXGo_BMX_NumAppearancesCalc
func BMXGo_BMX_NumAppearancesCalc(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.BMX")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMX{})).(*BMXGo.BMX).NumAppearancesCalc()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMX{})).(*BMXGo.BMX).NumAppearancesCalc()
	}
}

//export BMXGo_BMX_IDF_table_fill
func BMXGo_BMX_IDF_table_fill(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.BMX")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMX{})).(*BMXGo.BMX).IDF_table_fill()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMX{})).(*BMXGo.BMX).IDF_table_fill()
	}
}

//export BMXGo_BMX_E_tilde_table_fill
func BMXGo_BMX_E_tilde_table_fill(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.BMX")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMX{})).(*BMXGo.BMX).E_tilde_table_fill()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMX{})).(*BMXGo.BMX).E_tilde_table_fill()
	}
}

// --- wrapping struct: BMXGo.Config ---
//
//export BMXGo_Config_CTor
func BMXGo_Config_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_BMXGo_Config(&BMXGo.Config{}))
}

//export BMXGo_Config_DoLowercasing_Get
func BMXGo_Config_DoLowercasing_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_BMXGo_Config(handle)
	return boolGoToPy(op.DoLowercasing)
}

//export BMXGo_Config_DoLowercasing_Set
func BMXGo_Config_DoLowercasing_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_BMXGo_Config(handle)
	op.DoLowercasing = boolPyToGo(val)
}

//export BMXGo_Config_DoAmpersandNormalization_Get
func BMXGo_Config_DoAmpersandNormalization_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_BMXGo_Config(handle)
	return boolGoToPy(op.DoAmpersandNormalization)
}

//export BMXGo_Config_DoAmpersandNormalization_Set
func BMXGo_Config_DoAmpersandNormalization_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_BMXGo_Config(handle)
	op.DoAmpersandNormalization = boolPyToGo(val)
}

//export BMXGo_Config_DoSpecialCharsNormalization_Get
func BMXGo_Config_DoSpecialCharsNormalization_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_BMXGo_Config(handle)
	return boolGoToPy(op.DoSpecialCharsNormalization)
}

//export BMXGo_Config_DoSpecialCharsNormalization_Set
func BMXGo_Config_DoSpecialCharsNormalization_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_BMXGo_Config(handle)
	op.DoSpecialCharsNormalization = boolPyToGo(val)
}

//export BMXGo_Config_DoAcronymsNormalization_Get
func BMXGo_Config_DoAcronymsNormalization_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_BMXGo_Config(handle)
	return boolGoToPy(op.DoAcronymsNormalization)
}

//export BMXGo_Config_DoAcronymsNormalization_Set
func BMXGo_Config_DoAcronymsNormalization_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_BMXGo_Config(handle)
	op.DoAcronymsNormalization = boolPyToGo(val)
}

//export BMXGo_Config_DoPunctuationRemoval_Get
func BMXGo_Config_DoPunctuationRemoval_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_BMXGo_Config(handle)
	return boolGoToPy(op.DoPunctuationRemoval)
}

//export BMXGo_Config_DoPunctuationRemoval_Set
func BMXGo_Config_DoPunctuationRemoval_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_BMXGo_Config(handle)
	op.DoPunctuationRemoval = boolPyToGo(val)
}

// --- wrapping struct: BMXGo.ConvMessage ---
//
//export BMXGo_ConvMessage_CTor
func BMXGo_ConvMessage_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_BMXGo_ConvMessage(&BMXGo.ConvMessage{}))
}

//export BMXGo_ConvMessage_Role_Get
func BMXGo_ConvMessage_Role_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_BMXGo_ConvMessage(handle)
	return C.CString(op.Role)
}

//export BMXGo_ConvMessage_Role_Set
func BMXGo_ConvMessage_Role_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_BMXGo_ConvMessage(handle)
	op.Role = C.GoString(val)
}

//export BMXGo_ConvMessage_Content_Get
func BMXGo_ConvMessage_Content_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_BMXGo_ConvMessage(handle)
	return C.CString(op.Content)
}

//export BMXGo_ConvMessage_Content_Set
func BMXGo_ConvMessage_Content_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_BMXGo_ConvMessage(handle)
	op.Content = C.GoString(val)
}

//export BMXGo_ConvMessage_Date_Get
func BMXGo_ConvMessage_Date_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_ConvMessage(handle)
	return handleFromPtr_time_Time(&op.Date)
}

//export BMXGo_ConvMessage_Date_Set
func BMXGo_ConvMessage_Date_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_ConvMessage(handle)
	op.Date = *ptrFromHandle_time_Time(val)
}

//export BMXGo_ConvMessage_Intent_Get
func BMXGo_ConvMessage_Intent_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_BMXGo_ConvMessage(handle)
	return C.CString(op.Intent)
}

//export BMXGo_ConvMessage_Intent_Set
func BMXGo_ConvMessage_Intent_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_BMXGo_ConvMessage(handle)
	op.Intent = C.GoString(val)
}

//export BMXGo_ConvMessage_LinkedContent_Get
func BMXGo_ConvMessage_LinkedContent_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_ConvMessage(handle)
	return handleFromPtr_Slice_BMXGo_LinkedContent(&op.LinkedContent)
}

//export BMXGo_ConvMessage_LinkedContent_Set
func BMXGo_ConvMessage_LinkedContent_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_ConvMessage(handle)
	op.LinkedContent = deptrFromHandle_Slice_BMXGo_LinkedContent(val)
}

// --- wrapping struct: BMXGo.LLMClient ---
//
//export BMXGo_LLMClient_CTor
func BMXGo_LLMClient_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_BMXGo_LLMClient(&BMXGo.LLMClient{}))
}

// --- wrapping struct: BMXGo.LinkedContent ---
//
//export BMXGo_LinkedContent_CTor
func BMXGo_LinkedContent_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_BMXGo_LinkedContent(&BMXGo.LinkedContent{}))
}

//export BMXGo_LinkedContent_ID_Get
func BMXGo_LinkedContent_ID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_BMXGo_LinkedContent(handle)
	return C.CString(op.ID)
}

//export BMXGo_LinkedContent_ID_Set
func BMXGo_LinkedContent_ID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_BMXGo_LinkedContent(handle)
	op.ID = C.GoString(val)
}

//export BMXGo_LinkedContent_Type_Get
func BMXGo_LinkedContent_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_BMXGo_LinkedContent(handle)
	return C.CString(op.Type)
}

//export BMXGo_LinkedContent_Type_Set
func BMXGo_LinkedContent_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_BMXGo_LinkedContent(handle)
	op.Type = C.GoString(val)
}

// --- wrapping struct: BMXGo.TextPreprocessor ---
//
//export BMXGo_TextPreprocessor_CTor
func BMXGo_TextPreprocessor_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_BMXGo_TextPreprocessor(&BMXGo.TextPreprocessor{}))
}

//export BMXGo_TextPreprocessor_Process
func BMXGo_TextPreprocessor_Process(_handle CGoHandle, item *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.TextPreprocessor")
	if __err != nil {
		return handleFromPtr_Slice_string(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(BMXGo.TextPreprocessor{})).(*BMXGo.TextPreprocessor).Process(C.GoString(item))

	return handleFromPtr_Slice_string(&cret)
}

//export BMXGo_TextPreprocessor_ProcessMany
func BMXGo_TextPreprocessor_ProcessMany(_handle CGoHandle, items CGoHandle, nWorkers C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.TextPreprocessor")
	if __err != nil {
		return handleFromPtr_Slice_Slice_string(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(BMXGo.TextPreprocessor{})).(*BMXGo.TextPreprocessor).ProcessMany(deptrFromHandle_Slice_string(items), int(nWorkers))

	return handleFromPtr_Slice_Slice_string(&cret)
}

//export BMXGo_TextPreprocessor_SetStemmer
func BMXGo_TextPreprocessor_SetStemmer(_handle CGoHandle, stemmerName *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.TextPreprocessor")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(BMXGo.TextPreprocessor{})).(*BMXGo.TextPreprocessor).SetStemmer(C.GoString(stemmerName))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export BMXGo_TextPreprocessor_SetStopwords
func BMXGo_TextPreprocessor_SetStopwords(_handle CGoHandle, stopwords *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.TextPreprocessor")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(BMXGo.TextPreprocessor{})).(*BMXGo.TextPreprocessor).SetStopwords(C.GoString(stopwords))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: BMXGo.BMXAdapter ---
//
//export BMXGo_BMXAdapter_CTor
func BMXGo_BMXAdapter_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_BMXGo_BMXAdapter(&BMXGo.BMXAdapter{}))
}

//export BMXGo_BMXAdapter_AddMany
func BMXGo_BMXAdapter_AddMany(_handle CGoHandle, ids CGoHandle, docs CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.BMXAdapter")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMXAdapter{})).(*BMXGo.BMXAdapter).AddMany(deptrFromHandle_Slice_string(ids), deptrFromHandle_Slice_string(docs))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export BMXGo_BMXAdapter_Search
func BMXGo_BMXAdapter_Search(_handle CGoHandle, query *C.char, topK C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.BMXAdapter")
	if __err != nil {
		return handleFromPtr_BMXGo_SearchResults(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMXAdapter{})).(*BMXGo.BMXAdapter).Search(C.GoString(query), int(topK))

	return handleFromPtr_BMXGo_SearchResults(&cret)
}

//export BMXGo_BMXAdapter_SearchMany
func BMXGo_BMXAdapter_SearchMany(_handle CGoHandle, queries CGoHandle, topK C.longlong, maxConcurrent C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.BMXAdapter")
	if __err != nil {
		return handleFromPtr_Slice_BMXGo_SearchResults(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMXAdapter{})).(*BMXGo.BMXAdapter).SearchMany(deptrFromHandle_Slice_string(queries), int(topK), int(maxConcurrent))

	return handleFromPtr_Slice_BMXGo_SearchResults(&cret)
}

//export BMXGo_BMXAdapter_SearchAugmented
func BMXGo_BMXAdapter_SearchAugmented(_handle CGoHandle, query *C.char, topK C.longlong, num_augmented_queries C.longlong, weight C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.BMXAdapter")
	if __err != nil {
		return handleFromPtr_BMXGo_SearchResults(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMXAdapter{})).(*BMXGo.BMXAdapter).SearchAugmented(C.GoString(query), int(topK), int(num_augmented_queries), float64(weight))

	return handleFromPtr_BMXGo_SearchResults(&cret)
}

//export BMXGo_BMXAdapter_SearchAugmentedMany
func BMXGo_BMXAdapter_SearchAugmentedMany(_handle CGoHandle, queries CGoHandle, topK C.longlong, num_augmented_queries C.longlong, weight C.double, maxConcurrent C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.BMXAdapter")
	if __err != nil {
		return handleFromPtr_Slice_BMXGo_SearchResults(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMXAdapter{})).(*BMXGo.BMXAdapter).SearchAugmentedMany(deptrFromHandle_Slice_string(queries), int(topK), int(num_augmented_queries), float64(weight), int(maxConcurrent))

	return handleFromPtr_Slice_BMXGo_SearchResults(&cret)
}

//export BMXGo_BMXAdapter_GetTokens
func BMXGo_BMXAdapter_GetTokens(_handle CGoHandle, text *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*BMXGo.BMXAdapter")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMXAdapter{})).(*BMXGo.BMXAdapter).GetTokens(C.GoString(text))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(BMXGo.BMXAdapter{})).(*BMXGo.BMXAdapter).GetTokens(C.GoString(text))
	}
}

// --- wrapping struct: BMXGo.ChatCompletionRequest ---
//
//export BMXGo_ChatCompletionRequest_CTor
func BMXGo_ChatCompletionRequest_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_BMXGo_ChatCompletionRequest(&BMXGo.ChatCompletionRequest{}))
}

//export BMXGo_ChatCompletionRequest_Models_Get
func BMXGo_ChatCompletionRequest_Models_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_ChatCompletionRequest(handle)
	return handleFromPtr_Slice_string(&op.Models)
}

//export BMXGo_ChatCompletionRequest_Models_Set
func BMXGo_ChatCompletionRequest_Models_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_ChatCompletionRequest(handle)
	op.Models = deptrFromHandle_Slice_string(val)
}

//export BMXGo_ChatCompletionRequest_Messages_Get
func BMXGo_ChatCompletionRequest_Messages_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_ChatCompletionRequest(handle)
	return handleFromPtr_Slice_BMXGo_ConvMessage(&op.Messages)
}

//export BMXGo_ChatCompletionRequest_Messages_Set
func BMXGo_ChatCompletionRequest_Messages_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_ChatCompletionRequest(handle)
	op.Messages = deptrFromHandle_Slice_BMXGo_ConvMessage(val)
}

//export BMXGo_ChatCompletionRequest_Stream_Get
func BMXGo_ChatCompletionRequest_Stream_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_BMXGo_ChatCompletionRequest(handle)
	return boolGoToPy(op.Stream)
}

//export BMXGo_ChatCompletionRequest_Stream_Set
func BMXGo_ChatCompletionRequest_Stream_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_BMXGo_ChatCompletionRequest(handle)
	op.Stream = boolPyToGo(val)
}

//export BMXGo_ChatCompletionRequest_Temperature_Get
func BMXGo_ChatCompletionRequest_Temperature_Get(handle CGoHandle) C.float {
	op := ptrFromHandle_BMXGo_ChatCompletionRequest(handle)
	return C.float(op.Temperature)
}

//export BMXGo_ChatCompletionRequest_Temperature_Set
func BMXGo_ChatCompletionRequest_Temperature_Set(handle CGoHandle, val C.float) {
	op := ptrFromHandle_BMXGo_ChatCompletionRequest(handle)
	op.Temperature = float32(val)
}

//export BMXGo_ChatCompletionRequest_MaxTokens_Get
func BMXGo_ChatCompletionRequest_MaxTokens_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_BMXGo_ChatCompletionRequest(handle)
	return C.longlong(op.MaxTokens)
}

//export BMXGo_ChatCompletionRequest_MaxTokens_Set
func BMXGo_ChatCompletionRequest_MaxTokens_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_BMXGo_ChatCompletionRequest(handle)
	op.MaxTokens = int(val)
}

// --- wrapping struct: BMXGo.ClientConfig ---
//
//export BMXGo_ClientConfig_CTor
func BMXGo_ClientConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_BMXGo_ClientConfig(&BMXGo.ClientConfig{}))
}

//export BMXGo_ClientConfig_APIKey_Get
func BMXGo_ClientConfig_APIKey_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	return C.CString(op.APIKey)
}

//export BMXGo_ClientConfig_APIKey_Set
func BMXGo_ClientConfig_APIKey_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	op.APIKey = C.GoString(val)
}

//export BMXGo_ClientConfig_BaseURL_Get
func BMXGo_ClientConfig_BaseURL_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	return C.CString(op.BaseURL)
}

//export BMXGo_ClientConfig_BaseURL_Set
func BMXGo_ClientConfig_BaseURL_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	op.BaseURL = C.GoString(val)
}

//export BMXGo_ClientConfig_HTTPClient_Get
func BMXGo_ClientConfig_HTTPClient_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	return handleFromPtr_Ptr_http_Client(op.HTTPClient)
}

//export BMXGo_ClientConfig_HTTPClient_Set
func BMXGo_ClientConfig_HTTPClient_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	op.HTTPClient = ptrFromHandle_Ptr_http_Client(val)
}

//export BMXGo_ClientConfig_AppName_Get
func BMXGo_ClientConfig_AppName_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	return C.CString(op.AppName)
}

//export BMXGo_ClientConfig_AppName_Set
func BMXGo_ClientConfig_AppName_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	op.AppName = C.GoString(val)
}

//export BMXGo_ClientConfig_AppURL_Get
func BMXGo_ClientConfig_AppURL_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	return C.CString(op.AppURL)
}

//export BMXGo_ClientConfig_AppURL_Set
func BMXGo_ClientConfig_AppURL_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	op.AppURL = C.GoString(val)
}

//export BMXGo_ClientConfig_Provider_Get
func BMXGo_ClientConfig_Provider_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	return C.CString(op.Provider)
}

//export BMXGo_ClientConfig_Provider_Set
func BMXGo_ClientConfig_Provider_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	op.Provider = C.GoString(val)
}

//export BMXGo_ClientConfig_ResourceName_Get
func BMXGo_ClientConfig_ResourceName_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	return C.CString(op.ResourceName)
}

//export BMXGo_ClientConfig_ResourceName_Set
func BMXGo_ClientConfig_ResourceName_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	op.ResourceName = C.GoString(val)
}

//export BMXGo_ClientConfig_DeploymentName_Get
func BMXGo_ClientConfig_DeploymentName_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	return C.CString(op.DeploymentName)
}

//export BMXGo_ClientConfig_DeploymentName_Set
func BMXGo_ClientConfig_DeploymentName_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_BMXGo_ClientConfig(handle)
	op.DeploymentName = C.GoString(val)
}

// --- wrapping struct: BMXGo.Document ---
//
//export BMXGo_Document_CTor
func BMXGo_Document_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_BMXGo_Document(&BMXGo.Document{}))
}

//export BMXGo_Document_Text_Get
func BMXGo_Document_Text_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_BMXGo_Document(handle)
	return C.CString(op.Text)
}

//export BMXGo_Document_Text_Set
func BMXGo_Document_Text_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_BMXGo_Document(handle)
	op.Text = C.GoString(val)
}

//export BMXGo_Document_Tokens_Get
func BMXGo_Document_Tokens_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_Document(handle)
	return handleFromPtr_Slice_string(&op.Tokens)
}

//export BMXGo_Document_Tokens_Set
func BMXGo_Document_Tokens_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_Document(handle)
	op.Tokens = deptrFromHandle_Slice_string(val)
}

//export BMXGo_Document_F_table_Get
func BMXGo_Document_F_table_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_BMXGo_Document(handle)
	return handleFromPtr_Map_string_int(&op.F_table)
}

//export BMXGo_Document_F_table_Set
func BMXGo_Document_F_table_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_BMXGo_Document(handle)
	op.F_table = deptrFromHandle_Map_string_int(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export BMXGo_NewConfig
func BMXGo_NewConfig(tokenizer *C.char, stemmer *C.char, lang *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := BMXGo.NewConfig(C.GoString(tokenizer), C.GoString(stemmer), C.GoString(lang))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_BMXGo_Config(nil)
	}
	return handleFromPtr_Ptr_BMXGo_Config(cret)
}

//export BMXGo_NewLLMClient
func BMXGo_NewLLMClient(config CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_BMXGo_LLMClient(BMXGo.NewLLMClient(*ptrFromHandle_BMXGo_ClientConfig(config)))

}

//export BMXGo_NewTextPreprocessor
func BMXGo_NewTextPreprocessor(config CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_BMXGo_TextPreprocessor(BMXGo.NewTextPreprocessor(ptrFromHandle_Ptr_BMXGo_Config(config)))

}

//export BMXGo_Build
func BMXGo_Build(indexName *C.char, config CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := BMXGo.Build(C.GoString(indexName), *ptrFromHandle_BMXGo_Config(config))

	return handleFromPtr_BMXGo_BMXAdapter(&cret)
}

// ---- Functions ---

//export BMXGo_GetStopwords
func BMXGo_GetStopwords(swList *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := BMXGo.GetStopwords(C.GoString(swList))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_string(nil)
	}
	return handleFromPtr_Slice_string(&cret)
}

//export BMXGo_HtmlToMarkdown
func BMXGo_HtmlToMarkdown(htmlContent *C.char, addIDs C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(BMXGo.HtmlToMarkdown(C.GoString(htmlContent), boolPyToGo(addIDs)))

}

//export BMXGo_NormalizeAmpersand
func BMXGo_NormalizeAmpersand(text *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(BMXGo.NormalizeAmpersand(C.GoString(text)))

}

//export BMXGo_NormalizeSpecialChars
func BMXGo_NormalizeSpecialChars(text *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(BMXGo.NormalizeSpecialChars(C.GoString(text)))

}

//export BMXGo_GenerateAugmentedQueries
func BMXGo_GenerateAugmentedQueries(query *C.char, num_augmented_queries C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := BMXGo.GenerateAugmentedQueries(C.GoString(query), int(num_augmented_queries))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_string(nil)
	}
	return handleFromPtr_Slice_string(&cret)
}

//export BMXGo_Lowercasing
func BMXGo_Lowercasing(text *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(BMXGo.Lowercasing(C.GoString(text)))

}

//export BMXGo_NormalizeAcronyms
func BMXGo_NormalizeAcronyms(text *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(BMXGo.NormalizeAcronyms(C.GoString(text)))

}

//export BMXGo_StripWhitespaces
func BMXGo_StripWhitespaces(text *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(BMXGo.StripWhitespaces(C.GoString(text)))

}

//export BMXGo_ApplyStemmer
func BMXGo_ApplyStemmer(tokens CGoHandle, stemmer *C.PyObject) CGoHandle {
	_fun_arg := stemmer
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := BMXGo.ApplyStemmer(deptrFromHandle_Slice_string(tokens), func(arg_0 string) string {
		if C.PyCallable_Check(_fun_arg) == 0 {
			return C.GoString(nil)
		}
		_gstate := C.PyGILState_Ensure()
		_fcargs := C.PyTuple_New(1)
		C.PyTuple_SetItem(_fcargs, 0, C.gopy_build_string(C.CString(arg_0)))
		_fcret := C.PyObject_CallObject(_fun_arg, _fcargs)
		C.gopy_decref(_fcargs)
		C.gopy_err_handle()
		C.PyGILState_Release(_gstate)
		return C.GoString(C.PyBytes_AsString(_fcret))
	})

	return handleFromPtr_Slice_string(&cret)
}

//export BMXGo_NormalizeDiacritics
func BMXGo_NormalizeDiacritics(text *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(BMXGo.NormalizeDiacritics(C.GoString(text)))

}

//export BMXGo_RemoveEmptyTokens
func BMXGo_RemoveEmptyTokens(tokens CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := BMXGo.RemoveEmptyTokens(deptrFromHandle_Slice_string(tokens))

	return handleFromPtr_Slice_string(&cret)
}

//export BMXGo_RemovePunctuation
func BMXGo_RemovePunctuation(text *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(BMXGo.RemovePunctuation(C.GoString(text)))

}
